- [前言](#前言)
- [HTTP协议的主要特点](#http协议的主要特点)
  - [简单快速](#简单快速)
  - [灵活](#灵活)
  - [无连接](#无连接)
  - [无状态](#无状态)
- [HTTP报文的组成部分](#http报文的组成部分)
  - [请求报文包括：](#请求报文包括)
  - [响应报文包括：](#响应报文包括)
- [HTTP方法](#http方法)
- [get 和 post的区别](#get-和-post的区别)
- [http状态码](#http状态码)
- [持久链接/http长连接](#持久链接http长连接)
- [长连接中的管线化](#长连接中的管线化)
  - [管线化的原理](#管线化的原理)
  - [管线化的注意事项](#管线化的注意事项)
- [TCP协议](#tcp协议)
  - [TCP三次握手](#tcp三次握手)
  - [TCP四次挥手](#tcp四次挥手)
- [HTTPS的原理和作用](#https的原理和作用)

## 前言

一面要讲的内容：

  * HTTP协议的主要特点

  * HTTP报文的组成部分

  * HTTP方法

  * get 和 post的区别

  * HTTP状态码

  * 什么是持久连接

  * 什么是管线化

二面要讲的内容；

  * 缓存

  * CSRF攻击

## HTTP协议的主要特点

  * 简单快速

  * 灵活

  * **无连接**

  * **无状态**

通常我们要答出以上四个内容。如果实在记不住，一定要记得后面的两个： **无连接、无状态** 。

我们分别来解释一下。

### 简单快速

**简单** ：每个资源（比如图片、页面）都通过 url 来定位。这都是固定的，在http协议中，处理起来也比较简单，想访问什么资源，直接输入url即可。

### 灵活

http协议的头部有一个`数据类型`，通过http协议，就可以完成不同数据类型的传输。

### 无连接

连接一次，就会断开，不会继续保持连接。

### 无状态

客户端和服务器端是两种身份。第一次请求结束后，就断开了，第二次请求时， **服务器端并没有记住之前的状态**
，也就是说，服务器端无法区分客户端是否为同一个人、同一个身份。

有的时候，我们访问网站时，网站能记住我们的账号，这个是通过其他的手段（比如 session）做到的，并不是http协议能做到的。

## HTTP报文的组成部分

[![](https://camo.githubusercontent.com/3776b3dd209ee8fb439e9cc7a718e1d96a9961b1d9249ddd2807e6776b3ba72d/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303330365f313430302e706e67)](https://camo.githubusercontent.com/3776b3dd209ee8fb439e9cc7a718e1d96a9961b1d9249ddd2807e6776b3ba72d/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303330365f313430302e706e67)

在回答此问题时，我们要按照顺序回答：

  * 先回答的是，http报文包括： **请求报文** 和 **响应报文** 。

  * 再回答的是，每个报文包含什么部分。

  * 最后回答，每个部分的内容是什么

### 请求报文包括：

[![](https://camo.githubusercontent.com/3cdd2cfe28502eb329d61b00f68bf4be6d1d7b93ce55c85b02563cc1ed846efa/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303232385f313530352e6a7067)](https://camo.githubusercontent.com/3cdd2cfe28502eb329d61b00f68bf4be6d1d7b93ce55c85b02563cc1ed846efa/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303232385f313530352e6a7067)

  * 请求行：包括请求方法、请求的url、http协议及版本。

  * 请求头：一大堆的键值对。

  * **空行** 指的是：当服务器在解析请求头的时候，如果遇到了空行，则表明，后面的内容是请求体。

  * 请求体：数据部分。

### 响应报文包括：

[![](https://camo.githubusercontent.com/5a06f9e21a22759fff5cbd19d73e11cd0e6e79ddf927bb5da379039b7d346f47/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303232385f313531302e6a7067)](https://camo.githubusercontent.com/5a06f9e21a22759fff5cbd19d73e11cd0e6e79ddf927bb5da379039b7d346f47/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303232385f313531302e6a7067)

  * 状态行：http协议及版本、状态码及状态描述。

  * 响应头

  * 空行

  * 响应体

## HTTP方法

包括：

  * GET：获取资源

  * POST：传输资源

  * put：更新资源

  * DELETE：删除资源

  * HEAD：获得报文首部

HTTP方法有很多，但是上面这五个方法，要求在面试时全部说出来，不要漏掉。

get 和 post 比较常见。

put 和 delete 在实际应用中用的很少。况且，业务中，一般不删除服务器端的资源。

head 可能偶尔用的到。

## get 和 post的区别

[![](https://camo.githubusercontent.com/eb94fc7050d60f1ba087c92805b0b4f5ba3b331fb790e5b5fc3b926f7216e28e/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303330365f313431352e706e67)](https://camo.githubusercontent.com/eb94fc7050d60f1ba087c92805b0b4f5ba3b331fb790e5b5fc3b926f7216e28e/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303330365f313431352e706e67)

区别有很多，如果记不住，面试时，至少要任意答出其中的三四条。

有一点要强调， **get是相对不隐私的，而post是相对隐私的** 。

我们大概要记住以下几点：

1、浏览器在回退时，get **不会重新请求** ，但是post会重新请求。【重要】

2、get请求会被浏览器 **主动缓存** ，而post不会。【重要】

3、get请求的参数，会 **保留** 在浏览器的 **历史记录**
里，而post不会。做业务时要注意。为了防止CSRF攻击，很多公司把get统一改成了post。

4、get请求在url中传递的参数有大小限制，基本是2kb，不同的浏览器略有不同。而post没有限制。

5、get的参数是直接暴露在url上的，相对不安全。而post是放在请求体中的。

## http状态码

http状态码分类：

[![](https://camo.githubusercontent.com/f6cb65a6c2747251a830bc7a74cf514bbef7f05e7434f41145ea9b790aadc595/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303330365f313433302e706e67)](https://camo.githubusercontent.com/f6cb65a6c2747251a830bc7a74cf514bbef7f05e7434f41145ea9b790aadc595/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303330365f313433302e706e67)

部分解释：

  - 200 OK，表示从客户端发来的请求在服务器端被正常处理了。
  - 204 No content ，表示请求处理成功，但没有资源返回。
  - 301 moved permanently，表示永久性重定向。表示请求的资源被分配了新的URI，以后应使用资源现在所指的URI。
  - 302 found，表示临时性重定向。
  - 304 表示客户端发送附带条件的请求时（指采用GET方法的请求报文中包含if-matched,if-modified-since,if-none-match,if-range,if-unmodified-since任一个首部）服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304Modified（服务器端资源未改变，可直接使用客户端未过期的缓存）
  - 400 bad request，表示请求报文中存在语法错误。
  - 401 unauthorized，表示未授权
  - 403 forbidden，表示对请求资源的访问被服务器拒绝了
  - 404 not found，表示服务器上无法找到请求的资源。
  - 500 internal sever error，表示服务器端在执行请求时发生了错误。
  - 501 Not Implemented，服务器不支持当前请求所需要的某个功能
  - 503 service unavailable，表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。

## 持久链接/http长连接

> 如果你能答出持久链接，这是面试官很想知道的一个点。

  * **轮询** ：http1.0中，客户端每隔很短的时间，都会对服务器发出请求，查看是否有新的消息，只要轮询速度足够快，例如1秒，就能给人造成交互是实时进行的印象。这种做法是无奈之举，实际上对服务器、客户端双方都造成了大量的性能浪费。

  * **长连接** ：HTTP1.1中，通过使用Connection:keep-alive进行长连接，。客户端只请求一次，但是服务器会将继续保持连接，当再次请求时，避免了重新建立连接。

注意，HTTP 1.1默认进行持久连接。在一次 TCP 连接中可以完成多个 HTTP 请求，但是对 **每个请求仍然要单独发 header** ，Keep-
Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。

## 长连接中的管线化

> 如果能答出 **管线化** ，则属于加分项。

### 管线化的原理

长连接时， **默认** 的请求这样的：

    
    
    	请求1 --> 响应1 -->请求2 --> 响应2 --> 请求3 --> 响应3
    

长连接中的管线化，请求是这样的：

    
    
    	请求1 --> 请求2 --> 请求3 --> 响应1 --> 响应2 --> 响应3
    

管线化就是，我把现在的请求打包，一次性发过去，你也给我一次响应回来。

### 管线化的注意事项

面试时，不会深究管线化。如果真要问你，就回答：“我没怎么研究过，准备回去看看~”

## TCP协议
中文名：传输控制协议（Transmission Control Protocol）。是一种面向连接的、可靠的、基于字节流的传输层通信协议。

http 和 TCP 的关系？

http协议是位于应用层，用来定义 request 和 response 的规则，而 TCP 位于传输层，用来传输客户端、服务端的 request、response。

### TCP三次握手
**含义**

由于TCP是面向连接的，所以客户端和服务端发送数据前要先建立一条连接在TCP/IP协议中，连接建立成功后再开始正式传输数据，TCP三次握手就是用于建立该连接。

**步骤**

1. 第一次握手: 客户端发送请求，询问是否同意建立连接

2. 第二次握手: 服务器收到信息, 并请求与客户端建立连接

3. 第三次握手: 客户端收到信息系, 同意与服务器建立连接

**作用**

一、二次握手是为了保证服务端能接收客户端信息并作出应答，二、三次握手是为了保证客户端能接受到服务端信息并做应答。

### TCP四次挥手
**含义**

当数据传输完毕，就需要断开TCP连接，TCP四次挥手就是用于断开TCP连接。

**步骤**

1. 第一次分手: 客户端发送断开请求

2. 第二次分手: 服务器收到断开请求, 发送同意断开连接的请求

3. 第三次分手: 服务器发送请求断开连接

4. 第四次分手: 客户端收到, 发送同意断开连接

## HTTPS的原理和作用
HTTPS 还是通过了 HTTP 来传输信息，但是信息通过 TLS 协议进行了加密。

要讲清楚https，需要知道以下几个知识点

1. 对称加密与非对称加密的概念
2. SSL/TLS 协议的含义
3. CA 证书的用途

**对称加密与非对称加密**

秘钥：一种算法

加密：通过秘钥将明文变成密文的过程

解密：通过秘钥将密文变成明文的过程

对称加密：对称加密就是两边拥有相同的秘钥，两边都知道如何将密文加密解密

非对称加密：有公钥私钥之分，公钥所有人都可以知道，可以将数据用公钥加密，但是将数据解密必须使用私钥解密，私钥只有分发公钥的一方才知道

**SSL/TLS 协议**

**作用**：http 协议是明文的，存在传输内容会被偷窥和篡改等问题，SSL协议就是为了解决这些问题。

1999年，SSL被标准化，标准化后改名为 TLS（Transport Layer Security），中文叫“传输层安全协议”。所以 SSL 和 TLS 指的是同一个东西。

**TLS 握手过程**

![](https://yck-1254263422.cos.ap-shanghai.myqcloud.com/blog/2019-06-01-043749.jpg)

1. 客户端发送一个随机值，需要的协议和加密方式
2. 服务端收到客户端的随机值，自己也产生一个随机值，并根据客户端需求的协议和加密方式来使用对应的方式，发送自己的证书（如果需要验证客户端证书需要说明）
3. 客户端收到服务端的证书并验证是否有效，验证通过会再生成一个随机值，通过服务端证书的公钥去加密这个随机值并发送给服务端，如果服务端需要验证客户端证书的话会附带证书
4. 服务端收到加密过的随机值并使用私钥解密获得第三个随机值，这时候两端都拥有了三个随机值，可以通过这三个随机值按照之前约定的加密方式生成密钥，接下来的通信就可以通过该密钥来加密解密

通过以上步骤可知，在 TLS 握手阶段，两端使用非对称加密的方式来通信，但是因为非对称加密损耗的性能比对称加密大，所以在正式传输数据时，两端使用对称加密的方式通信。


**原文：**

https://github.com/qianguyihao/Web/blob/master/13-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/01-%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/04-HTTP%E5%8D%8F%E8%AE%AE.md