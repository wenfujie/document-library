- [渲染器的设计](#渲染器的设计)
  - [基本概念](#基本概念)
  - [render 方法的实现](#render-方法的实现)
  - [patch 函数更新 DOM 的过程](#patch-函数更新-dom-的过程)

# 渲染器的设计

> 渲染器就是用来执行渲染任务的，在浏览器平台上，用它来渲染真实 DOM。通常渲染器具有可自定义能力，这是框架支持跨平台的关键。

本篇讨论的渲染器限定在 DOM 平台上。

最基本的渲染器

```js
function renderer(domString, container) {
  container.innerHTML = domString;
}
```

使用

```js
renderer("<h1>hello</h1>", document.getElementById("app"));
```

## 基本概念

> 通常使用 `renderer` 表示渲染器，不要把 `renderer` 和 `render` 搞混，后者是动词。渲染器渲染 `DOM` 的过程叫做挂载用 `mount` 表示。

渲染器使用 `render` 方法用于渲染 `DOM`

```js
function createRenderer() {
  function render(vnode, container) {
    // ...
  }
  return { render };
}

const renderer = createRenderer()
renderer.render(...)
```

渲染器应该支持多平台渲染，例如 Vue 还支持 `hydrate` 用于服务端渲染

```js
function createRenderer() {
  function render(vnode, container) {
    // ...
  }
  function hydrate(vnode, container) {
    // ... 同构渲染（服务端渲染时用到）
  }
  return { render, hydrate };
}

const renderer = createRenderer()
renderer.hydrate(...)
```

## render 方法的实现

```js
function createRenderer() {
  function render(vnode, container) {
    if (vnode == null) {
      // 如果 vnode 不存在，表示需要卸载组件
      if (container._vnode) {
        unmount(container._vnode, null, null, true);
      }
    } else {
      // 否则进入更新流程（初始化创建也是特殊的一种更新）
      patch(container._vnode || null, vnode, container);
    }
    // 缓存 vnode
    container._vnode = vnode;
  }
  return { render };
}
```

## patch 函数更新 DOM 的过程

`patch` 函数

```js
// packages/runtime-core/src/renderer.ts
function patch(n1,n2,container = null,anchor = null,parentComponent = null) {
  // 对于类型不同的新老节点，直接进行卸载
  if (n1 && !isSameVNodeType(n1, n2)) {
    anchor = getNextHostNode(n1)
    unmount(n1, parentComponent, parentSuspense, true)
    n1 = null
  }
  // 基于 n2 的类型来判断
  // 因为 n2 是新的 vnode
  const { type, shapeFlag } = n2;
  switch (type) {
    case Text:
       // 处理文本节点
      break;
    // 其中还有几个类型比如： static fragment comment
    default:
      // 这里就基于 shapeFlag 来处理
      if (shapeFlag & ShapeFlags.ELEMENT) {
        // 处理普通 DOM 元素
        processElement(n1, n2, container, anchor, parentComponent);
      } else if (shapeFlag & ShapeFlags.COMPONENT) {
        // 处理 component
        processComponent(n1, n2, container, parentComponent);
      } else if {
        // ... 处理其他元素
      }
  }
}
```

> 基于 `isSameVNodeType` 方法判断是否是同种类型的 `VNode` ，不同类型调用 `unmount` 方法删除节点，若是相同类型则调用各种类型的处理函数进行处理如：`processElement` 、`processComponent` ...

`processComponent` 函数

```js
// packages/runtime-core/src/renderer.ts
function processComponent(n1, n2, container, parentComponent) {
  // 如果 n1 没有值的话，那么就是 mount
  if (!n1) {
    // 初始化 component
    mountComponent(n2, container, parentComponent);
  } else {
    updateComponent(n1, n2, container);
  }
}
```

`mountComponent` 函数

```js
// packages/runtime-core/src/renderer.ts
function mountComponent(initialVNode, container, parentComponent) {
  // 1. 先创建一个 component instance
  const instance = (initialVNode.component = createComponentInstance(
    initialVNode,
    parentComponent
  ));

  // 2. 初始化 instance 上的 props, slots, 执行组件的 setup 函数...
  setupComponent(instance);

  // 3. 设置并运行带副作用的渲染函数
  setupRenderEffect(instance, initialVNode, container);
}
```

`createComponentInstance` 方法返回值

```js
// packages/runtime-core/src/component.ts
const instance = {
  // 这里是组件对象
  type: vnode.type,
  // 组件 vnode
  vnode,
  // 新的组件 vnode
  next: null,
  // props 相关
  props: {},
  // 指向父组件
  parent,
  // 依赖注入相关
  provides: parent ? parent.provides : {},
  // 渲染上下文代理
  proxy: null,
  // 标记是否被挂载
  isMounted: false,
  // attrs 相关
  attrs: {},
  // slots 相关
  slots: {},
  // context 相关
  ctx: {},
  // setup return 的状态数据
  setupState: {},
  // ...
};
```

`setupComponent` 函数

```js
// packages/runtime-core/src/component.ts
export function setupComponent(instance) {
  // 1. 处理 props
  // 取出存在 vnode 里面的 props
  const { props, children } = instance.vnode;
  initProps(instance, props);
  // 2. 处理 slots
  initSlots(instance, children);

  // 3. 调用 setup 并处理 setupResult
  setupStatefulComponent(instance);
}
```

`setupRenderEffect` 函数

```js
// packages/runtime-core/src/renderer.ts
const setupRenderEffect = (
  instance,
  initialVNode,
  container,
  anchor,
  parentSuspense,
  isSVG,
  optimized
) => {
  function componentUpdateFn() {
    if (!instance.isMounted) {
      // 渲染子树的 vnode
      const subTree = (instance.subTree = renderComponentRoot(instance));
      // 挂载子树 vnode 到 container 中
      patch(null, subTree, container, anchor, instance, parentSuspense, isSVG);
      // 把渲染生成的子树根 DOM 节点存储到 el 属性上
      initialVNode.el = subTree.el;
      instance.isMounted = true;
    } else {
      // 更新相关，后面介绍
    }
  }
  // 创建副作用渲染函数
  instance.update = effect(componentUpdateFn, prodEffectOptions);
};
```

> `setupRenderEffect` 中会调用 `renderComponentRoot` 函数，该函数中会触发组件的 `render` 函数。

`render` 函数会返回 VNode 树。（若用户手写 `render` 函数那会直接返回，否则会在构建阶段把 `Template` 解析为 `render` 函数。）

```js
import { openBlock, createElementBlock } from "vue"

const _hoisted_1 = { class: "helloWorld" }

export function render(...) {
  return (openBlock(), createElementBlock("div", _hoisted_1, " hello world "))
}
```

`createElementBlock` 函数

```js
// packages/runtime-core/src/vnode.ts
export const createElementBlock = (...) => {
  return setupBlock(
    createBaseVNode(
      type,
      props,
      children,
      patchFlag,
      dynamicProps,
      shapeFlag,
      true /* isBlock */
    )
  )
};
```

> `createElementBlock` 函数调用了 `createBaseVNode ` 创建和返回 `VNode` ，此时 `VNode` 的 `shapeFlags`

值为 `ELEMENT` 。

> `setupRenderEffect` 方法中，在拿到 `VNode` 后会调用 `patch` 方法， `patch` 方法中判断 `shapeFlags` 值为 `ELEMENT` 会执行 `processElement` 方法

`processElement` 方法

```js
// packages/runtime-core/src/renderer.ts
function processElement(n1, n2, container, anchor, parentComponent) {
  if (!n1) {
    // 挂载元素节点
    mountElement(n2, container, anchor);
  } else {
    // 更新元素节点
    updateElement(n1, n2, container, anchor, parentComponent);
  }
}
```

`mountElement` 方法

```js
// packages/runtime-core/src/renderer.ts
const mountElement = (
  vnode,
  container,
  anchor,
  parentComponent,
  parentSuspense,
  isSVG,
  optimized
) => {
  let el;
  const { type, props, shapeFlag, transition, patchFlag, dirs } = vnode;
  // ...
  // 根据 vnode 创建 DOM 节点
  el = vnode.el = hostCreateElement(vnode.type, isSVG, props && props.is);
  if (props) {
    // 处理 props 属性
    for (const key in props) {
      if (!isReservedProp(key)) {
        hostPatchProp(el, key, null, props[key], isSVG);
      }
    }
  }
  // 文本节点处理
  if (shapeFlag & ShapeFlags.TEXT_CHILDREN) {
    hostSetElementText(el, vnode.children);
  } else if (shapeFlag & ShapeFlags.ARRAY_CHILDREN) {
    // 如果节点是个数据类型，则递归子节点
    mountChildren(vnode.children, el);
  }
  // 把创建好的 el 元素挂载到容器中
  hostInsert(el, container, anchor);
};
```

> `mountElemet` 首先是通过 `hostCreateElement` 创建了一个 `DOM` 节点，然后处理一下 `props` 属性，接着根据 `shapeFlag` 判断子节点的类型，如果节点是个文本节点，则直接创建文本节点。

如果子节点是个数组，比如这种情况：

```js
return (
  openBlock(),
  createElementBlock("div", _hoisted_1, [
    hoisted_2,
    createVNode(_component_Hello),
  ])
);
```

> `VNode` 的 `shapeFlag` 将是一个数组类型 `ARRAY_CHILDREN`，针对该类型 `VNode` 会调用 `mountChildren` 方法递归触发 `patch` 进行渲染。

最后通过 `hostInsert` 方法挂载节点

```js
// packages/runtime-dom/src/nodeOps.ts
insert: (child, parent, anchor) {
  parent.insertBefore(child, anchor || null)
}
```

至此，渲染器基本成型，调用 `render` 方法后即可完成 `VNode` 树的渲染。
