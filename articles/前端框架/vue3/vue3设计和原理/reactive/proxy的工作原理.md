# proxy 的工作原理

## 对象的内部方法

js 中，对象的语义是由对象的 `内部方法` 指定的。`内部方法` 指的是当我们对一个对象进行操作时在引擎内部调用的方法，并且这些方法对 js 使用者来说是不可见的。

举例说明

```js
obj.foo;
```

引擎内部会调用 `[[Get]]` 这个内部方法来读取属性值。

以下是对象部分 `内部方法`

| 左对齐             |                                    右对齐 |        居中对齐        |
| :----------------- | ----------------------------------------: | :--------------------: |
| [[Get]]            |            (propertyKey, Receiver) => any |       获取属性值       |
| [[Set]]            | (propertyKey, value, Receiver) => Boolean |       设置属性值       |
| [[Delete]]         |                  (propertyKey) => Boolean |       删除属性值       |
| [[GetPrototypeOf]] |                        () => Object\|Null | 获取提供继承属性的对象 |

## 内部方法的多态性

js 的内部方法具有多态性，这有点类似于面向对象里多态的概念。不同类型的对象部署了相同的内部方法，却具有不同的逻辑。

例如，普通对象和 proxy 对象都部署了 `[[Get]]` 方法，但它们的逻辑是不同的。

```js
const p = new Proxy(obj, {
  /* ... */
});
p.foo;
```

p 是一个代理对象，当执行 `p.foo` 引擎会调用部署在 p 上的内部方法 `[[Get]]` ，代理对象的 `[[Get]]` 和普通对象的逻辑不同，它会优先执行拦截函数 `get()` ，若没有设置拦截函数，代理对象的内部方法 `[[Get]]` 会调用原始对象的内部方法 `[[Get]]` 来获取属性值，这就是 `代理透明性质` 。


## 总结

综上得知，js针对代理对象，重写了底层内部方法，使得在执行代理对象语义时，让拦截函数优先，不存在拦截函数才执行原始对象内部方法，利用 `代理透明性质` 实现了对象代理。