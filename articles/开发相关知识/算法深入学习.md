<!--
 * @Date: 2021-09-19 09:32:32
 * @LastEditors: wenfujie
 * @LastEditTime: 2021-09-23 12:48:35
 * @FilePath: /document-library/articles/开发相关知识/算法深入学习.md
-->

- [1. 数据结构](#1-数据结构)
  - [1.1 数组](#11-数组)
  - [1.2 栈（Stack）——只用 pop 和 push 完成增删的“数组”](#12-栈stack只用-pop-和-push-完成增删的数组)
  - [1.3 队列（Queue）——只用 push 和 shift 完成增删的“数组”](#13-队列queue只用-push-和-shift-完成增删的数组)
  - [1.4 链表](#14-链表)
  - [1.5 树](#15-树)
- [2. 算法基础技能](#2-算法基础技能)
  - [2.1 时间复杂度和空间复杂度](#21-时间复杂度和空间复杂度)
  - [2.2 反转字符串](#22-反转字符串)
  - [2.3 判断回文字符串](#23-判断回文字符串)
  - [2.4 数组排序](#24-数组排序)
- [3. 算法技巧](#3-算法技巧)
  - [3.1 对撞双指针](#31-对撞双指针)
  - [3.1 快慢双指针](#31-快慢双指针)

## 1. 数据结构

### 1.1 数组

避免篇幅过长，数组就不多做介绍了，前端算法嘛如果数组都不了解那趁早回去洗洗睡吧 😴。

但是要点名的是，相比 `forEach、map` 等内置遍历方法，使用 for 遍历 Array 类型的数据是最高效的。

```js
for (let i = 0; i < arr.length; i++) {}
```

### 1.2 栈（Stack）——只用 pop 和 push 完成增删的“数组”

栈是类似数组的一种数据结构，栈遵循 `后进先出(LIFO，Last In First Out)` 原则，就好比我们把东西放到瓶子里，先放进去的都在瓶底，后放进去的就靠近瓶口，取得时候只能先把瓶口的东西先取出来才能取瓶底的东西。

栈的特征：

1. 只允许从尾部添加元素
2. 只允许从尾部取出元素

所以在 `JavaScript` 中，我们可以把栈理解为是仅有 `push` 和 `pop` 方法的一种特殊数组，`push` 负责往瓶子放东西，`pop` 负责移除。

![](./images/算法-栈.png)

看一个实例，用数组来模拟获取到最先进栈的元素：

```js
function getHead(stack) {
  let curr;
  while (stack.length) {
    curr = stack.pop();
  }
  return curr;
}

let stack = [];
stack.push(1);
stack.push(2);
getHead(stack); // 1
```

了解完啥是 `栈` 后，马上开工：

**有效的括号**

[前往力扣做题](https://leetcode-cn.com/problems/valid-parentheses/)

> 给定一个只包括 '('，')'，'{'，'}'，'['，']' 的字符串 s ，判断字符串是否有效。
> 有效字符串需满足：
>
> 1.  左括号必须用相同类型的右括号闭合。
> 2.  左括号必须以正确的顺序闭合。

```js
输入：s = "()"输出：true

输入：s = "()[]{}"输出：true

输入：s = "(]"输出：false

输入：s = "([)]"输出：false

输入：s = "{[]}"输出：true
```

注意：

- 1 <= s.length <= 104
- s 仅由括号 '()[]{}' 组成

思路分析：

1. 数组长度要是偶数，不然 return false
2. 需要一个 map 来做左右括号的匹配，需要定义一个栈存储括号
3. 遍历字符串，遇到左括号入栈，遇到右括号时出栈并判断与该右括号是否为配对括号，如果配对继续下一轮，否则 return false
4. 遍历结束后，如果栈内还剩元素 return false ，否则 return true

实现代码：

```js
const map = new Map([
  ["(", ")"],
  ["{", "}"],
  ["[", "]"],
]);

var isValid = function (s) {
  if (s.length % 2 !== 0) return false;
  let arr = [];

  for (let i = 0; i < s.length; i++) {
    if (map.has(s[i])) {
      arr.push(s[i]);
    } else {
      if (map.get(arr.pop()) !== s[i]) return false;
    }
  }
  return arr.length === 0;
};
```

实现代码中使用了 ES6 的 Map 数据类型，如果对 ES6 不太熟悉的同学，使用 Object 实现也行哈。

可能有的同学觉得还不够过瘾，这边在罗列几道跟 `栈` 相关的常出题型，大家有空可以练练手：

- [每日温度](https://leetcode-cn.com/problems/iIQa4I/)：尝试用 `递减栈` 将时间复杂度降低到 `O(n)`
- [最小栈](https://leetcode-cn.com/problems/min-stack/)：这题很有意思，颠覆你的认知，居然能做到用 `O(1)` 来获取最小值

### 1.3 队列（Queue）——只用 push 和 shift 完成增删的“数组”

队列也是类似数组的一种数据结构，栈遵循 `先进先出（FIFO，First In First Out）` 原则。类似去食堂排队，排在前面的人取到餐后就可以先走了，而后头的人只能等前面的人走后才能取餐。

队列的特征：

1. 只能从头部移除元素
2. 只能从尾部添加元素

所以在 `JavaScript` 中，我们可以把队列理解为是仅有 `push` 和 `shift` 方法的一种特殊数组，`push` 负责将元素添加到队列末尾，`pop` 负责将队列第一个元素移除。

看个示例，用数组模拟队列排队取餐：

```js
function queueUp(queue) {
  while (queue.length) {
    console.log(queue[0] + "已取餐");
    queue.shift();
  }
}
let queue = [];
queue.push("张三");
queue.push("李四");
queueUp(queue);
```

### 1.4 链表

链表一种 `线性结构` 的有序列表，但是它在内存中是离散的：

![](./images/NodeList_memory.awebp)

链表的每一项我们都称为 `结点（Node）` ，每个节点包含储存的值和指向下一个结点的指针。

**创建链表结点**

在 `JavaScript` 我们可以这样构造结点：

```js
class NodeList {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}

let node = new NodeList(1);
```

**添加链表结点**

添加结点主要是围绕 `next` 指针做文章。

参照上边图中，我们要让结点 1 指向结点 2： `1=>2` ，代码要这样处理：

```js
let node = new NodeList(1);
let node2 = new NodeList(2);
node.next = node2;
```

这样我们就完成了结点 2 的添加。

如果要在链表之间插入结点，我们要 `找到插入位置的前一个结点和后一个结点`，并将 `前一个结点的next指针指向要插入的目标结点`，`目标结点的next指针指向要插入位置的后一个结点`。

我们改造上面的代码，在结点 1 和结点 2 之间插入结点 3：

```js
let node = new NodeList(1);
let node2 = new NodeList(2);
node.next = node2;

let node3 = new NodeList(3);
node.next = node3;
node3.next = node2;
```

**删除链表结点**

删除链表结点，需找到要删除结点的 `前驱结点` 并更改它的 next 指向即可。只要结点没被引用，就会被 JS 的垃圾回收器回收。

例如我们要将上文的链表 `1=>3=>2` 中的结点 3 删除：

```js
node.next = node2;
```

所以删除结点的关键并不是 `目标结点` 而是 `前驱结点` 。

**链表和数组的对比**

- 高效增删

  简单数组（只包含基础数据类型）的内存是连续的，当插入或删除一个元素会导致后面的所有元素向后或向前移动，复杂度为 O(n)。

  链表的内存是离散的，当插入或删除结点时仅需修改前驱结点和目标结点的 next 指向，复杂度为 O(1)

- 复杂访问

  简单数组中内存是连续的，通过索引计算偏移量可直接获取到具体的元素如 `arr[8]` ，复杂度为 O(1)

  链表中要访问具体结点，必须通过遍历需访问指定次数的 next，复杂度为 O(n)

一句总结：`数组的访问效率高，操作效率低；链表的访问效率低，操作效率高` 。

### 1.5 树

## 2. 算法基础技能

这一节主要介绍 `如何计算算法的复杂度` 和一些必备的 `基础算法` 。

很多复杂算法都会依赖一些基础算法，比如 `数组升序排序` 在双指针算法技巧中就常常运用到，所以这一小节中罗列的必备基础技能，大家一定要着重记忆并加以刻意练习，也为了后面做中等甚至困难难度的算法题奠定基础。

### 2.1 时间复杂度和空间复杂度

一个算法好不好 ☝🏻，主要靠 `时间复杂度` 和 `空间复杂度` 来评判。如果是笔试题，我们可以使用更易实现的算法去实现哪怕它的 `时间复杂度` 和 `空间复杂度` 相对较高，因为我们的目的是让机器跑通过，但是如果是面试官在面试，那我们肯定要尽量选取 `时间复杂度` 和 `空间复杂度` 相对较低的去实现，这样面试官才会觉得"哎哟，不错哦 😉"。所以说学会计算法 `时间复杂度` 和 `空间复杂度` 还是很重要的 😎。

**时间复杂度**

概念性的东西比较抽象，我们结合代码来看，算算以下这段代码被调用时会被执行几次？

```js
function traverse(arr) {
  var len = arr.length;
  for (var i = 0; i < len; i++) {
    console.log(arr[i]);
  }
}
```

1. 首先 `var len = arr.length` 和 `var i=0` 只执行一次，得到 `1+1`
2. 然后 `console.log(arr[i])` 和 `i++` 会执行 `arr.length` 次，也就是 n 次，所以得到 `n+n`
3. 最后 `i<len` 总会比 `i++` 多一次，也就是 n+1 次

合计：(1+1) + (n+n) + (n+1) = 3n + 3

也就是 `O(3n + 3)`，但是时间复杂度不是要计算代码总执行次数，而是要反映出影响代码总执行次数的 `变化趋势` ，所以它遵守以下规则：

1. 如果是常数，都简化为 1：O(100) => `O(1)`
2. 如果是多项式，只取最高项，且系数简化为 1：O(3n + 3) => `O(n)`

> 注意：空间复杂度亦遵循该规则。

所以上面例子的时间复杂度为：`O(n)` 。

综上我们还可以总结出，当算法具有外层嵌套一层内层遍历时，可直观看出算法时间复杂度为 `O(n^2)` ，因为其他项可直接忽略。那如果算法有 x 层嵌套遍历时，其时间复杂度为 `O(n^x)` 。

常用的复杂度除了 `常数项( O(1) )`、`多项式( O(n), O(n^2) )` 外，还有 `logn` 。可能很多人都不太记得啥是 `logn` ：

> 以 log2 n 为例：计算以 2 为底的对数（log2 n）为了得到数字 n 必须将 2 乘方多少次。

> 例如，log2 1 = 0，log2 2 = 1，log2 4 = 2，log2 32 = 5。

我们回到代码中：

```js
function fn(arr) {
  var len = arr.length;
  for (var i = 1; i < len; i = i * 2) {
    console.log(arr[i]);
  }
}
```

这段代码咋一看感觉跟上面的例子一样，时间复杂度为 `O(n)` ，实则不然，我们假设循环体会执行 n 次，`i=i*2` 同样会执行 n 次，所以 i 的值的变化经历：

```js
i = i*2 // 第一次
i = i*2*2 // 第二次
i = i*2*2*2 // 第三次
...
i = i*2*2*2*2...*2 // 第n次，乘以 n 个 2
```

数学好的同学可能已经看出来了

```js
i = i * log2n;
```

所以可以求出该例子的时间复杂度为 `O(log2n)` ，通常会把底数去掉计为 `O(logn)` 。

常见的时间复杂度按照从小到大的顺序排列，有以下几种：
![](./images/有哪些时间复杂度.awebp)

**空间复杂度**

`空间复杂度` 相对比较好理解了，主要用来度量算法在运行过程中 `内存占用的增长趋势` 。

常用的 `空间复杂度` 有 `O(1)、O(n) 、 O(n^2)` 。

来看个例子：

```js
function traverse(arr) {
  var len = arr.length;
  for (var i = 0; i < len; i++) {
    console.log(arr[i]);
  }
}
```

运行这段代码，会在内存开辟空间，储存变量 `arr、len、i` ，并且变量内存空间不再变化，所以 `空间复杂度` 为 `O(1)` 。

再来看另一个例子：

```js
function init(n) {
  var arr = [];
  for (var i = 0; i < n; i++) {
    arr[i] = i;
  }
  return arr;
}
```

这个例子同样在内存开辟空间，储存变量 `arr、n、i` ，但在运行过程中 arr 占用空间一直在增大，并且是与 n 等比增长的，所以 `空间复杂度` 为 `O(n)` 。

`时间复杂度` 和 `空间复杂度` 暂时就介绍这些，大家可以在下文实战做题时，算算自己的算法实现是怎样的复杂度。

平时做算法时多思考思考 🤔，有没有更低复杂度的解法，在学习算法的过程中，培养这样的意识非常重要，因为在大厂的算法面试中，写出算法只是第一步，面试官更看重的是你能否对代码逻辑以及性能做优化。只有在平时做算法时多去思考、不断优化解法，才能在面试中游刃有余 😉。

### 2.2 反转字符串

利用数组的 `reverse` 方法

```js
const str = "hello world";

str = str.split("").reverse().join(""); // 'dlrow olleh'
```

### 2.3 判断回文字符串

> 回文字符串：正读和反读都一样的字符串，比如“level”或者“noon”等等就是回文串。

**判断方法一**

由于回文字符串正序和反序会相同，我们可利用这一特性并结合 `2.2 反转字符串` 小节来判断是否是回文字符串：

```js
function isPalindrome(str) {
  const reversedStr = str.split("").reverse().join("");
  // 判断反转前后是否相等
  return reversedStr === str;
}
```

**判断方法二**

遍历字符串，每次比较 `第i项` 与 `str.length - 1 - i项` 是否相同，遍历到数组的一半即可结束遍历。

```js
function isPalindrome(str) {
  const len = str.length;
  for (let i = 0; i < len / 2; i++) {
    if (str[i] !== str[len - 1 - i]) {
      return false;
    }
  }
  return true;
}
```

### 2.4 数组排序

前端提供了原生的排序方法，那就是数组的 `sort方法` 。

```js
let arr = [4, 2, 1, 3];

// 升序
arr.sort((a, b) => a - b); // [1,2,3,4]

// 降序
arr.sort((a, b) => b - a); // [4,3,2,1]
```

在写算法的过程，如果有依赖排序时直接使用上述方式进行排序即可。虽然有开箱即用的方法，但是一些经典的排序算法我们还是要掌握的。主要掌握以下 5 种即可：

基础排序算法：

- 冒泡排序
- 插入排序
- 选择排序

进阶排序算法

- 归并排序
- 快速排序

学习排序算法，我们首要是理解算法的原理，而不是背诵去默写代码，排序算法的复杂度不会很高，知道排序的原理，正常情况下都能推导并写出实现代码来 😉。

**冒泡排序**

冒泡排序的原理：从第 1 个元素开始，比较相邻的两个项，若前者比后者大那两元素互换位置，否则位置不变。一轮比较下来后，数组末尾的项为最大值。以此类推，进行 n 轮后数组就按从小到大排序。

来看下数组进行冒泡排序一轮的过程：

```js
[7, 2, 1, 5, 3]
 ↑  ↑
[2, 7, 1, 5, 3]
    ↑  ↑
[2, 1, 7, 5, 3]
       ↑  ↑
[2, 1, 5, 7, 3]
          ↑  ↑
[2, 1, 5, 3, 7]
```

可以看出，数组经过一轮后，数组末尾的项为该数组的最大值 7 。要注意的是，既然每一轮都能在末尾排序一个项，那进行下一轮时就不必和已排序好的项进行比较了。

代码实现：

```js
function bubbleSort(arr) {
  let len = arr.length;

  for (let i = 0; i < len; i++) {
    // 避免和排序好的项作比较，所以结束判断为 j < len - 1 - i
    for (let j = 0; j < len - 1 - i; j++) {
      // 若前一项比后一项大，则互换位置
      if (arr[j] > arr[j + 1]) {
        [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]];
      }
    }
  }
  return arr;
}
```

理论上，给出上面👆🏻的代码后冒泡排序就打完收工了，同学们可以算算 `时间复杂度` 是多少（ 答案是 O(n^2) ）。

突然，面试官话锋一转说，如果我用一个已经排序好的数组来跑这段代码， `时间复杂度` 是多少？你算了下，说 `O(n^2)` 。面试官开心的笑了说，那你试着优化成 `O(n)` 。

其实不难，一开始我们并未考虑数组是有序的情况，如果能判断数组是有序的，那直接 return 掉就好，避免不必要的遍历和判断。

问题怎么判断数组是有序的呢？很简单，如果一轮遍历下来都没有经历互换位置，那数组就是有序的。

优化下代码：

```js
function bubbleSort(arr) {
  let len = arr.length;
  let swapped = false;
  
  for (let i = 0; i < len; i++) {
    // 是否交换位置
    swapped = false;
    for (let j = 0; j < len - 1 - i; j++) {
      if (arr[j] > arr[j + 1]) {
        [arr[j + 1], arr[j]] = [arr[j], arr[j + 1]];
        swapped = true;
      }
    }
    // 未交换位置，表示数组是有序的
    if (swapped === false) return arr;
  }
  return arr;
}
```

优化后的代码，增加了是否交换过位置的判断，如果数组是有序的，那外循环只会遍历一次，所以 `时间复杂度` 是 `O(n)` ， 避免掉数组是有序后的额外开销，给面试官一个满意的答卷😉。

**选择排序**

选择排序原理：遍历数组，找到最小的数并移动到数组头部，缩小搜索范围继续下一次遍历..直到排序完成。

选择排序就是这么无脑，不多说直接看代码：

```js
function selectSort(arr) {
  if (arr.length <= 1) return arr;
  // 记录最小数的索引
  let minIndex;
  // 仅需遍历到倒数第2个数
  for (let j = 0; j < arr.length - 1; j++) {
    minIndex = j;
    for (let i = j + 1; i < arr.length; i++) {
      if (arr[i] < arr[minIndex]) {
        minIndex = i;
      }
    }
    // 将该轮最小值与头部值互换位置
    [arr[j], arr[minIndex]] = [arr[minIndex], arr[j]]
  }
  return arr;
}
```

需注意的是，外层遍历只需遍历到倒数第 2 个，因为在倒数第 2 个时仅剩当前项和末尾项，所以该轮结束后数组就已经是有序的了。快速排序 `时间复杂度` 为 `O(n^2)` 。

**插入排序**

插入排序原理：假设数组头部是有序的，遍历数组将每一项插入到数组头部中并保持有序性。

描述有点抽象，来看个演算过程：

```js
// 最开始有序的头部是 [3]
[3,1,4,2]
// 开始遍历，从索引 1 开始，1 > 3 需将 1 移到 3 之前，有序头部变为 [1,3]
[3,1,4,2] => [1,3,4,2]
   ↑
// 当前项为 4 ，4 需插入到 [1,3] 的末尾，有序头部变为 [1,3,4]
[1,3,4,2] => [1,3,4,2]
     ↑
// 当前项为 2 ，2 需插入到 3 之前，有序头部变为 [1,2,3,4]
[1,3,4,2] => [1,2,3,4]
       ↑
```

看完演算，应该能理解了，下面上代码：

```js
function insertSort(arr) {
  let curr;
  for (let i = 1; i < arr.length; i++) {
    for (let j = 0; j < i; j++) {
      if (arr[j] >= arr[i]) {
        // 将当前项插入到头部指定位置，维持有序性
        arr.splice(j, 0, arr.splice(i, 1)[0]);
      }
    }
  }
  return arr;
}
```

插入排序 `时间复杂度` 为 `O(n^2)` 。

比较基础的三种排序算法讲完了，一般情况下它们的 `时间复杂度` 都是 `O(n^2)` ，👇🏻下面要说的就是两种进阶的排序算法 `归并排序` 和 `快速排序` ，这两种排序方式会比前面三种复杂一些，但它们的 `时间复杂度` 也相对来说更低。

**归并排序**

归并排序的原理：将数组从中间切开，得到2个数组，将2个数组从中间切开，得到4个数组，将4个数组...如此循环直到每个被切开的数组仅剩一个数为止，再将切开的数组两两合并且保持有序，直到完整的数组有序。

有点抽象，看下算法演算过程：

```js
// 第一轮分割
[3,1,4,|2,0] => [3,1,4] [2,0]

// 第二轮分割
[3,1,|4] => [3,1] [4] ， [2,|0] => [2] [0]

// 第三轮分割
[3,|1] => [3] [1] ， [4] ， [2] [0]

// 分割结果
[3] [1] [4] [2] [0]

// 第一轮合并
[3] [1] [4] [2] [0] => [1,3] [2,4] [0]
 →   ←   →   ←
// 第二轮合并
[1,3] [2,4] [0] => [1,2,3,4] [0]
  →     ←
// 第三轮合并
[1,3,4] [0] => [0,1,2,3,4]
   →     ←
```

有的同学看完后可能有点懵了😳，排序而已搞介么复杂，又是分割又是合并的。但是同学们，可不能光看人的外表啊，得注重内在（好像在相亲🤷‍♂️🤷‍♀️）。虽然它的实现过程复杂，但是 `时间复杂度` 低啊对不，人面试官问你，你知道哪些排序算法，你反手一套 3 连：`冒泡` `选择` `插入` ，那人面试官就得追问了，有木有其他性能更好的捏？所以啊，把 `归并` 学好👌，够他喝一壶得了。

扯了半天，那 `归并排序` 的 `时间复杂度` 是多少呢？一起来算下：

1. 首先数组的对半分割要执行 `log2n` 次，看演算过程，每一轮分割是针对所有子集的，所以是 `log2n` 次而不是 n 喔😯。分割一次数组的 `时间复杂度` 为 `O(1)` ，所以整个数组分割的复杂度为：`分割次数 * 分割一次的复杂度 = O(log2n * 1) = O(logn)` 
2. 合并数组与分割数组是类似的，需执行 `log2n` 次。合并两个数组并且保持有序，用 `双指针` （下文有专门篇幅介绍）实现 `时间复杂度` 为 `O(n)` 。所以所有子集合并的复杂度为 `合并次数 * 合并一次的复杂度 = O(log2n * n) = O(nlogn)` 

综合以上可得 `归并排序` 的 `时间复杂度` 为：`总分割 +  总合并 = O(logn) + O(nlogn) = O((n+1)logn)` ，通常直接计为 `O(nlogn)` 。

在👆🏻上文篇幅关于 `时间复杂度` 的介绍中可知，`O(nlogn) < O(n^2)` ，所以相对前面三个排序算法来说 `归并` 在 `时间复杂度` 上更胜一筹。 

## 3. 算法技巧

### 3.1 对撞双指针

> `对撞双指针`：在有序数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。

只要遇到 `数组、求和、对比大小` 的算法，我们就要想到对撞双指针，使用对撞指针的前提需要数组是有序的，这是一种常用解题思路。

对撞双指针的伪代码：

```js
function fn (list) {
  var left = 0;
  var right = list.length - 1;

  //遍历数组
  while (left <= right) {
    left++;
    // 一些条件判断 和处理
    ... ...
    right--;
  }
}
```

来看个对撞双指针算法题：

**救生艇**

[前往力扣做题](https://leetcode-cn.com/problems/boats-to-save-people/)

> 第  i  个人的体重为  people[i]，每艘船可以承载的最大重量为  limit。每艘船最多可同时载两人，但条件是这些人的重量之和最多为  limit。返回载到每一个人所需的最小船数。(保证每个人都能被船载)。

示例：

输入：people = [3,2,2,1], limit = 3

输出：3

解释：3 艘船分别载 (1, 2), (2) 和 (3)

**解题分析**

1. 将数组按升序排序，定义最终需要船的数量 result = 0
2. 左指针指向索引 0，右指针指向末尾
3. 两指针相加<=limit,左右指针向中间移一步，result++
4. 两指针相加>limit,右指针左移，result++
5. 当 left >= right 结束遍历
6. 最后如果两指针指向同一索引，表示该索引未处理，result++

**解题代码**

```js
/**
 * @param {number[]} people
 * @param {number} limit
 * @return {number}
 */
var numRescueBoats = function (people, limit) {
  let left = 0,
    right = people.length - 1,
    result = 0;
  people = people.sort((a, b) => a - b);
  while (left < right) {
    while (left < right && people[left] + people[right] > limit) {
      right--;
      result++;
    }
    while (left < right && people[left] + people[right] <= limit) {
      left++;
      right--;
      result++;
    }
  }
  if (left === right) {
    result++;
  }
  return result;
};
```

这题相对简单，下面来题难度大些的：

**三数之和**

[前往力扣做题](https://leetcode-cn.com/problems/3sum/)

> 给你一个包含 n 个整数的数组  nums，判断  nums  中是否存在三个元素 a，b，c ，使得  a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例：

输入：nums = [-1,0,1,2,-1,-4]

输出：[[-1,-1,2],[-1,0,1]]

这题看起来相当复杂，看完题目可以发现，又是 `数组、求和`，所以我们思路可以往对撞双指针这边靠，利用对撞双指针降低复杂度：

**解题思路**

1. 将数组按升序排序
2. 遍历数组，双指针放在当前项的下一项和数组末尾
3. 判断当前项和两个指针值的和与 0 相减，如果结果为 0 表示成立，如果<0 把 left 指针向右移，如果>0 把 right 指针向左移。
4. 为避免重复，移动指针到下一个时遇到相同的数需跳过

**解题代码**

```js
var threeSum = function (nums) {
  let result = [];
  const len = nums.length;

  if (len < 3) return result;
  nums = nums.sort((a, b) => a - b);

  // len - 2 是因为遍历到倒数第三个，左右指针各指向最后两个数
  for (let i = 0; i < len - 2; i++) {
    // 避免重复，相同的数直接跳过
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    let left = i + 1, // 左指针
      right = len - 1; // 右指针
      
    while (left < right) {
      if (nums[i] + nums[left] + nums[right] === 0) {
        result.push([nums[i], nums[left], nums[right]]);
        left++;
        right--;
        // 左指针遇到相同的数跳过
        while (left < right && left - i > 1 && nums[left] === nums[left - 1]) {
          left++;
        }
        // 右指针遇到相同的数跳过
        while (left < right && nums[right] === nums[right + 1]) {
          right--;
        }
      } else if (nums[i] + nums[left] + nums[right] < 0) {
        left++;
        // 左指针遇到相同的数跳过
        while (left < right && left - i > 1 && nums[left] === nums[left - 1]) {
          left++;
        }
      } else {
        right--;
        // 右指针遇到相同的数跳过
        while (left < right && nums[right] === nums[right + 1]) {
          right--;
        }
      }
    }
  }
  return result;
};
```

这题算还是挺有难度的，很多边界情况需要考虑，学习算法过程中大家一定要多动手写代码，有时候有思路并不表示能写出代码，只有经过需要大量练习把算法思路刻在脑海里，在面试的高压下才能快速反应。

### 3.1 快慢双指针
