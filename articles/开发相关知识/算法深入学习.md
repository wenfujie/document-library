<!--
 * @Date: 2021-09-19 09:32:32
 * @LastEditors: wenfujie
 * @LastEditTime: 2021-09-20 09:29:52
 * @FilePath: /document-library/articles/开发相关知识/算法深入学习.md
-->

- [1. 数据结构](#1-数据结构)
  - [1.1 数组](#11-数组)
  - [1.2 栈（Stack）——只用 pop 和 push 完成增删的“数组”](#12-栈stack只用-pop-和-push-完成增删的数组)
  - [1.3 队列（Queue）——只用 push 和 shift 完成增删的“数组”](#13-队列queue只用-push-和-shift-完成增删的数组)
  - [1.4 链表](#14-链表)
  - [1.5 树](#15-树)
- [2. 算法常用套路](#2-算法常用套路)
  - [2.1 双指针](#21-双指针)

## 1. 数据结构

### 1.1 数组

相比 `forEach、map` 等内置遍历方法，使用 for 遍历 Array 类型的数据是最高效的。

```js
for (let i = 0; i < arr.length; i++) {}
```

### 1.2 栈（Stack）——只用 pop 和 push 完成增删的“数组”

栈是类似数组的一种数据结构，栈遵循 `后进先出(LIFO，Last In First Out)` 原则，就好比我们把东西放到瓶子里，先放进去的都在瓶底，后放进去的就靠近瓶口，取得时候只能先把瓶口的东西先取出来才能取瓶底的东西。

栈的特征：

1. 只允许从尾部添加元素
2. 只允许从尾部取出元素

所以在 `JavaScript` 中，我们可以把栈理解为是仅有 `push` 和 `pop` 方法的一种特殊数组，`push` 负责往瓶子最上层里放东西，`pop` 负责从瓶子的最上层取东西。

![](./images/算法-栈.png)

看一个实例，用数组来模拟获取到最先进栈的元素：

```js
function getHead(stack) {
  let curr;
  while (stack.length) {
    curr = stack.pop();
  }
  return curr;
}

let stack = [];
stack.push(1);
stack.push(2);
getHead(stack); // 1
```

### 1.3 队列（Queue）——只用 push 和 shift 完成增删的“数组”

队列也是类似数组的一种数据结构，栈遵循 `先进先出（FIFO，First In First Out）` 原则。类似去食堂排队，排在前面的人取到餐后就可以先走了，而后头的人只能等前面的人走后才能取餐。

队列的特征：

1. 只能从头部移除元素
2. 只能从尾部添加元素

所以在 `JavaScript` 中，我们可以把队列理解为是仅有 `push` 和 `shift` 方法的一种特殊数组，`push` 负责将元素添加到队列末尾，`pop` 负责将队列第一个元素移除。

看个示例，用数组模拟队列排队取餐：

```js
function queueUp(queue) {
  while (queue.length) {
    console.log(queue[0] + "已取餐");
    queue.shift();
  }
}
let queue = [];
queue.push("张三");
queue.push("李四");
queueUp(queue);
```

### 1.4 链表

链表一种 `线性结构` 的有序列表，但是它在内存中是离散的：

![](./images/NodeList_memory.awebp)

链表的每一项我们都称为 `结点（Node）` ，每个节点包含储存的值和指向下一个结点的指针。

**创建链表结点**

在 `JavaScript` 我们可以这样构造结点：

```js
class NodeList {
  constructor(val) {
    this.val = val;
    this.next = null;
  }
}

let node = new NodeList(1);
```

**添加链表结点**

添加结点主要是围绕 `next` 指针做文章。

参照上边图中，我们要让结点 1 指向结点 2： `1=>2` ，代码要这样处理：

```js
let node = new NodeList(1);
let node2 = new NodeList(2);
node.next = node2;
```

这样我们就完成了结点 2 的添加。

如果要在链表之间插入结点，我们要 `找到插入位置的前一个结点和后一个结点`，并将 `前一个结点的next指针指向要插入的目标结点`，`目标结点的next指针指向要插入位置的后一个结点`。

我们改造上面的代码，在结点 1 和结点 2 之间插入结点 3：

```js
let node = new NodeList(1);
let node2 = new NodeList(2);
node.next = node2;

let node3 = new NodeList(3);
node.next = node3;
node3.next = node2;
```

**删除链表结点**

删除链表结点，需找到要删除结点的 `前驱结点` 并更改它的 next 指向即可。只要结点没被引用，就会被 JS 的垃圾回收器回收。

例如我们要将上文的链表 `1=>3=>2` 中的结点 3 删除：

```js
node.next = node2;
```

所以删除结点的关键并不是 `目标结点` 而是 `前驱结点` 。

**链表和数组的对比**

- 高效增删

  简单数组（只包含基础数据类型）的内存是连续的，当插入或删除一个元素会导致后面的所有元素向后或向前移动，复杂度为 O(n)。

  链表的内存是离散的，当插入或删除结点时仅需修改前驱结点和目标结点的 next 指向，复杂度为 O(1)

- 复杂访问

  简单数组中内存是连续的，通过索引计算偏移量可直接获取到具体的元素如 `arr[8]` ，复杂度为 O(1)

  链表中要访问具体结点，必须通过遍历需访问指定次数的 next，复杂度为 O(n)

一句总结：`数组的访问效率高，操作效率低；链表的访问效率低，操作效率高` 。

### 1.5 树

## 2. 算法常用套路

### 2.1 双指针

**对撞双指针**

> `对撞双指针`：在有序数组中，将指向最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，然后从两头向中间进行数组遍历。

只要遇到 `数组、求和、对比大小` 的算法，我们就要想到对撞双指针，使用对撞指针的前提需要数组是有序的，这是一种常用解题思路。

对撞双指针的伪代码：

```js
function fn (list) {
  var left = 0;
  var right = list.length - 1;

  //遍历数组
  while (left <= right) {
    left++;
    // 一些条件判断 和处理
    ... ...
    right--;
  }
}
```

来看个对撞双指针算法题：


**救生艇**

[前往力扣做题](https://leetcode-cn.com/problems/boats-to-save-people/)

> 第  i  个人的体重为  people[i]，每艘船可以承载的最大重量为  limit。每艘船最多可同时载两人，但条件是这些人的重量之和最多为  limit。返回载到每一个人所需的最小船数。(保证每个人都能被船载)。

示例：

输入：people = [3,2,2,1], limit = 3

输出：3

解释：3 艘船分别载 (1, 2), (2) 和 (3)

**解题分析**
1. 将数组按升序排序
2. 左指针指向索引0，右指针指向末尾
3. 两指针相加<=limit,左右指针向中间移一步，result++
4. 两指针相加>limit,右指针左移，result++
5. 当left >= right 结束遍历
6. 最后如果两指针指向同一索引，表示该索引未处理，result++

**解题代码**

```js
/**
 * @param {number[]} people
 * @param {number} limit
 * @return {number}
 */
var numRescueBoats = function (people, limit) {
  let left = 0,
    right = people.length - 1,
    result = 0;
  people = people.sort((a, b) => a - b);
  while (left < right) {
    while (left < right && people[left] + people[right] > limit) {
      right--;
      result++;
    }
    while (left < right && people[left] + people[right] <= limit) {
      left++;
      right--;
      result++;
    }
  }
  if (left === right) {
    result++;
  }
  return result;
};
```

这题相对简单，下面来题难度大些的：

**三数之和**

[前往力扣做题](https://leetcode-cn.com/problems/3sum/)

> 给你一个包含 n 个整数的数组  nums，判断  nums  中是否存在三个元素 a，b，c ，使得  a + b + c = 0 ？请你找出所有和为 0 且不重复的三元组。

注意：答案中不可以包含重复的三元组。

示例：

输入：nums = [-1,0,1,2,-1,-4]

输出：[[-1,-1,2],[-1,0,1]]

这题看起来相当复杂，看完题目可以发现，又是 `数组、求和`，所以我们思路可以往对撞双指针这边靠，利用对撞双指针降低复杂度：

**解题思路**

1. 将数组按升序排序
2. 遍历数组，双指针放在当前项的下一项和数组末尾
3. 判断当前项和两个指针值的和与 0 相减，如果结果为 0 表示成立，如果<0 把 left 指针向右移，如果>0 把 right 指针向左移。
4. 为避免重复，移动指针到下一个时遇到相同的数需跳过

**解题代码**

```js
var threeSum = function (nums) {
  let result = [];
  const len = nums.length;
  if (len < 3) return result;
  nums = nums.sort((a, b) => a - b);
  // len - 2 是因为遍历到倒数第三个，左右指针各指向最后两个数
  for (let i = 0; i < len - 2; i++) {
    // 避免重复，相同的数直接跳过
    if (i > 0 && nums[i] === nums[i - 1]) continue;
    let left = i + 1, // 左指针
      right = len - 1; // 右指针
    while (left < right) {
      if (nums[i] + nums[left] + nums[right] === 0) {
        result.push([nums[i], nums[left], nums[right]]);
        left++;
        right--;
        // 左指针遇到相同的数跳过
        while (left < right && left - i > 1 && nums[left] === nums[left - 1]) {
          left++;
        }
        // 右指针遇到相同的数跳过
        while (left < right && nums[right] === nums[right + 1]) {
          right--;
        }
      } else if (nums[i] + nums[left] + nums[right] < 0) {
        left++;
        // 左指针遇到相同的数跳过
        while (left < right && left - i > 1 && nums[left] === nums[left - 1]) {
          left++;
        }
      } else {
        right--;
        // 右指针遇到相同的数跳过
        while (left < right && nums[right] === nums[right + 1]) {
          right--;
        }
      }
    }
  }
  return result;
};
```

这题算还是挺有难度的，很多边界情况需要考虑，学习算法过程中大家一定要多动手写代码，有时候有思路并不表示能写出代码，只有经过需要大量练习把算法思路刻在脑海里，在面试的高压下才能快速反应。
