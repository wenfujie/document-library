- [观察者模式](#观察者模式)
- [单例模式](#单例模式)
- [外观模式](#外观模式)
- [代理模式](#代理模式)
- [工厂模式](#工厂模式)
- [策略模式](#策略模式)
- [状态模式](#状态模式)
- [总结](#总结)

## 观察者模式

观察者模式是面试的超高频考点。

观察者模式，又称发布订阅模式。发布者主要拥有：添加订阅，发布通知功能，订阅者主要有：接受通知，执行命令功能。

应用场景：

- Vue.js 的双向绑定
- Event Bus

**观察模式的简单实现：**
```js
class Publisher {
  constructor() {
    this.observers = [];
  }

  addObserver(observer) {
    this.observers.push(observer);
  }

  publish() {
    this.observers.forEach((item) => {
      item.receive();
    });
  }
}
class Observer {
  receive() {
    console.log("收到通知后执行命令");
  }
}

const obs = new Observer();
const publish = new Publisher();

publish.addObserver(obs);
publish.publish(); // 收到通知后执行命令
```

要进一步了解观察模式可以前往：
- [Vue双向绑定实现原理](../Vue/Vue源码解读.md#双向绑定实现)
- [手写EventBus](../手写代码/手写代码系列.md#实现EventBus)

## 单例模式

单例模式仅允许类或对象具有单个实例，并且它使用全局变量来存储该实例。

**实现方法**：判断是否存在该对象的实例，如果已存在则不再创建，如果不存在则创建实例并使用闭包将实例存起来

**使用场景**：适用于业务场景中只能存在一个的实例，比如弹窗，购物车

```javascript
// 懒汉式

let ShopCar = (function () {
  let instance;
  function init() {
    /*这里定义单例代码*/
    return {
      buy(good) {
        this.goods.push(good);
      },
      goods: [],
    };
  }
  return {
    getInstance: function () {
      if (!instance) {
        instance = init();
      }
      return instance;
    },
  };
})();
let car1 = ShopCar.getInstance();
let car2 = ShopCar.getInstance();
car1.buy("橘子");
car2.buy("苹果");
console.log(car1.goods); //[ '橘子', '苹果' ]
console.log(car1 === car2); // true
```

```javascript
// 饿汉式

var ShopCar = (function () {
  var instance = init();
  function init() {
    /*这里定义单例代码*/
    return {
      buy(good) {
        this.goods.push(good);
      },
      goods: [],
    };
  }
  return {
    getInstance: function () {
      return instance;
    },
  };
})();
let car1 = ShopCar.getInstance();
let car2 = ShopCar.getInstance();
car1.buy("橘子");
car2.buy("苹果"); //[ '橘子', '苹果' ]
console.log(car1.goods);
console.log(car1 === car2); // true
```

实现效果有两种，懒汉式和饿汉式，各有优劣，按需求使用

- 懒汉式在类加载时，不创建实例，因此类加载速度快，但运行时获取对象的速度慢；
- 饿汉式在类加载时就完成了初始化，所以类加载较慢，但获取对象的速度快

## 外观模式

**含义**：简而言之外观设计模式就是把多个子系统中复杂逻辑进行抽象，从而提供一个更统一、更简洁、更易用的 API。

很多我们常用的框架和库基本都遵循了外观设计模式，比如 JQuery 就把复杂的原生 DOM 操作进行了抽象和封装，并消除了浏览器之间的兼容问题，从而提供了一个更高级更易用的版本。

我们可以应用外观模式封装一个统一的 DOM 元素事件绑定/取消方法，用于兼容不同版本的浏览器和更方便的调用：

```js
// 绑定事件
function addEvent(element, event, handler) {
  if (element.addEventListener) {
    element.addEventListener(event, handler, false);
  } else if (element.attachEvent) {
    element.attachEvent("on" + event, handler);
  } else {
    element["on" + event] = fn;
  }
}

// 取消绑定
function removeEvent(element, event, handler) {
  if (element.removeEventListener) {
    element.removeEventListener(event, handler, false);
  } else if (element.detachEvent) {
    element.detachEvent("on" + event, handler);
  } else {
    element["on" + event] = null;
  }
}
```

## 代理模式

代理模式可以解决以下的问题：

- 增加对一个对象的访问控制
- 当访问一个对象的过程中需要增加额外的逻辑

```js
var User = {
    post: function () {
        console.log('发文章');
    },
    remove: function () {
        console.log('删除文章');
    }
}

var ProxyUser = {
    post: function () {
        if (有权限） {
            User.post();
        }

        console.log('没有权限发文章');
    },
    remove: funtion () {
        if (有权限） {
            User.remove();
        }

        console.log('没有权限删除文章');
    }
}
```

## 工厂模式

什么时候用？

当构造函数过多不方便管理，且需要创建的对象之间存在某些关联（有同一个父类、实现同一个接口等）时，不妨使用工厂模式

作用？

工厂模式提供一种集中化、统一化的方式，避免了分散创建对象导致的代码重复、灵活性差的问题。

打造一个可制造多品牌汽车的工厂

```js
// 汽车构造函数
function SuzukiCar(color) {
  this.color = color;
  this.brand = "Suzuki";
}

// 汽车构造函数
function HondaCar(color) {
  this.color = color;
  this.brand = "Honda";
}

// 汽车构造函数
function BMWCar(color) {
  this.color = color;
  this.brand = "BMW";
}

// 汽车品牌枚举
const BRANDS = {
  suzuki: 1,
  honda: 2,
  bmw: 3,
};

/**
 * 汽车工厂
 */
function CarFactory() {
  this.create = function (brand, color) {
    switch (brand) {
      case BRANDS.suzuki:
        return new SuzukiCar(color);
      case BRANDS.honda:
        return new HondaCar(color);
      case BRANDS.bmw:
        return new BMWCar(color);
      default:
        break;
    }
  };
}
```

## 策略模式

策略模式解难度不大，并且在面试中权重不高，所以能理解会使用即可。

策略模式简单来说就是利用对象映射，避免编写过多 `if else` 。

比如有这样一段代码：

```js
// 询价方法，接受价格标签和原价为入参
function askPrice(tag, originPrice) {
  // 处理预热价
  if (tag === "pre") {
    if (originPrice >= 100) {
      return originPrice - 20;
    }
    return originPrice * 0.9;
  }

  // 处理大促价
  if (tag === "onSale") {
    if (originPrice >= 100) {
      return originPrice - 30;
    }
    return originPrice * 0.8;
  }

  // 处理返场价
  if (tag === "back") {
    if (originPrice >= 200) {
      return originPrice - 50;
    }
    return originPrice;
  }
}
```

使用策略模式改造后：

```js
// 价格处理对象
let priceProcessor = {
  prePrice(originPrice) {
    if (originPrice >= 100) {
      return originPrice - 20;
    }
    return originPrice * 0.9;
  },
  salePrice(originPrice) {
    if (originPrice >= 100) {
      return originPrice - 30;
    }
    return originPrice * 0.8;
  },
  backPrice(originPrice) {
    if (originPrice >= 200) {
      return originPrice - 50;
    }
    return originPrice;
  },
};

// 询问价格 
function askPrice(tag, originPrice) {
  return priceProcessor[tag](originPrice);
}
```

使用策略模式的优势：

- 不同逻辑之间隔离开，不会互相影响。比如当修改 `prePrice` 逻辑后仅需让测试同学回归该类型价格的功能即可
- 方便增加新的价格，直接 `priceProcessor.newPrice` 即可

> 综上可以总结出来策略模式的定义：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。

用笔者自己的话来阐述：

> 将 if else 不同逻辑都独立到函数中，将这些函数映射到一个对象上，最后对外提供一个接口函数用于外部调用。

## 状态模式

> 状态模式(State Pattern) ：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。

```js
class Fox {
  constructor() {
    this.animationType = "default";
    this.foxLevel = 1;
  }
  // 动画处理器
  animationProcessor = {
    that: this,
    default() {
      console.log(`fox level 为 ${this.that.foxLevel} 的默认动画`);
    },
    feed() {
      console.log(`fox level 为 ${this.that.foxLevel} 的喂食动画`);
    },
    touch() {
      console.log(`fox level 为 ${this.that.foxLevel} 的抚摸动画`);
    },
    upLevel() {
      console.log(`fox level 为 ${this.that.foxLevel} 的升级动画`);
    },
    // 喂食、升级组合动画
    feedAndUpLevel() {
      console.log(`fox level 为 ${this.that.foxLevel} 的喂食并且升级动画`);
    },
  };

  // 触发动画
  triggerAnimation(animationType) {
    try {
      this.animationProcessor[animationType]();
    } catch (err) {
      console.error("执行动画出错", err.message);
    }
    this.animationType = animationType;
  }
}

const myFox = new Fox();
myFox.triggerAnimation("feed"); // fox level 为 1 的喂食动画
```

## 总结
