<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  3.2
  《闭包》
  含义：
  在函数a中返回b方法，b有使用到a中的变量。
  这样做可以让a中的变量在内存持久化。
  注意事项：
  易造成内存溢出，需手动注销闭包方法。使用过程需注意this指向。
  应用场景：
  构造函数、局部变量、单例模式、函数柯里化

  《函数式编程》
  含义：
  将业务代码抽象为一个个业务函数，最后将多个函数串联实现最终编码。
  概念
  函数柯里化：将接受多个入参的函数，转化为接受单个入参的函数（闭包）
  纯函数：传入固定参数，返回值不会变化的函数
  高阶函数：函数接受的参数类型为函数，或函数范围值为一个函数

  《防抖与节流》
  含义：
  防抖：短时间内多次触发函数，只取最后一次执行。
  节流：在一定的时间内，确保函数只会触发一次。
  实现：可复述实现逻辑

  《数据类型判断》
  typeof可判断的类型：number,string,boolean,object,function（忘记null,undefined）
  instanceof: [] instanceof Array => true(缺点：修改实例的原型后，会导致判断不准确)
  (漏掉：[] instanceof Object 同样返回 true)
  Object.property.toString.call(arr) 返回：'[object Array]'
  该种形式几乎可判断所有类型

  《数组扁平化》
  [1,[2,[3]]].flat(Infinity)
  (遗漏：递归计算没手写出来)

  《对象拷贝》
  浅拷贝：=，Object.assign(仅深拷贝第一层，更深层是浅拷贝)
  深拷贝：
  1.JSON.parse(JSON.stringify(obj))，缺点是null、
  undefined、function会消失。
  2.递归深拷贝
  回答问题：浅拷贝还有{...obj}，null并不会消失，递归深拷贝没
  写出来

  《原型和原型链》
  含义：可以通过构造函数来创建实例，构造函数的property属性指向
  实例的原型，实例的__proto__属性也指向原型，实例会继承原型上属性和方法
  当访问实例上的属性时，会先在实例本身上去查找，若找不到会根据原型链
  找到实例的原型并在原型查找该属性，若还是找不到，则继续在原型的原型
  上去查找，直到找到Object构造函数，他的原型是null，最后结束查找，这一条查找的
  链路就是原型链。
  有哪些继承方法：
  1.创建构造函数的实例
  2.两个构造函数间继承
  3.es6 class 的 extends
  回答问题：没回答出【原型链继承】【借用构造函数继承】【组合继承】
  【原型式继承】【寄生式继承】【寄生组合式继承】

  《构造函数和类》



</body>

</html>
<script>
  var maxProfit = function (prices) {
    const maxArr = prices.reduce((arr, item, index) => {
      for (let i = index + 1; i < prices.length; i++) {
        const arrItem = arr[index];
        const priceItem = prices[i];
        let differ = prices[i] - item;
        if (arrItem) {
          if (differ > arrItem) {
            arr[index] = differ;
          }
        } else {
          arr[index] = differ > 0 ? differ : 0;
        }
      }
      return arr;
    }, [])
    return Math.max(...maxArr);
  };

  var singleNumber = function (nums) {
    let map = new Map();
    let item;
    for (let i = 0; i < nums.length; i++) {
      item = nums[i];
      if (map.has(item)) {
        map.delete(item)
      } else {
        map.set(item, item)
      }
    }
    return [...map.keys()][0];
  };

  console.log(singleNumber([2, 2, 1]));

  // 主要
  // 语音播报规则、插播规则
  // 应用于声连万象、智能音箱


  // 流程

  // 创建广告推送任务（包含：播放规则、播放素材、播放时间、播放点位）

  // 分发到喇叭的过程

  // 喇叭根据播放规则播放

  // 1.是否冲突
  // 是=>2.
  // 否=>直接播放
  // 2.比较优先级
  // 高=>根据插播规则播放
  // 低=>不执行
</script>