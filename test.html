<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  3.2
  《闭包》
  含义：
  在函数a中返回b方法，b有使用到a中的变量。
  这样做可以让a中的变量在内存持久化。
  注意事项：
  易造成内存溢出，需手动注销闭包方法。使用过程需注意this指向。
  应用场景：
  构造函数、局部变量、单例模式、函数柯里化

  《函数式编程》
  含义：
  将业务代码抽象为一个个业务函数，最后将多个函数串联实现最终编码。
  概念
  函数柯里化：将接受多个入参的函数，转化为接受单个入参的函数（闭包）
  纯函数：传入固定参数，返回值不会变化的函数
  高阶函数：函数接受的参数类型为函数，或函数范围值为一个函数

  《防抖与节流》
  含义：
  防抖：短时间内多次触发函数，只取最后一次执行。
  节流：在一定的时间内，确保函数只会触发一次。
  实现：可复述实现逻辑

  《数据类型判断》
  typeof可判断的类型：number,string,boolean,object,function（忘记null,undefined）
  instanceof: [] instanceof Array => true(缺点：修改实例的原型后，会导致判断不准确)
  (漏掉：[] instanceof Object 同样返回 true)
  Object.property.toString.call(arr) 返回：'[object Array]'
  该种形式几乎可判断所有类型

  《数组扁平化》
  [1,[2,[3]]].flat(Infinity)
  (遗漏：递归计算没手写出来)

  《对象拷贝》
  浅拷贝：=，Object.assign(仅深拷贝第一层，更深层是浅拷贝)
  深拷贝：
  1.JSON.parse(JSON.stringify(obj))，缺点是null、
  undefined、function会消失。
  2.递归深拷贝
  回答问题：浅拷贝还有{...obj}，null并不会消失，递归深拷贝没
  写出来

  《原型和原型链》
  含义：可以通过构造函数来创建实例，构造函数的property属性指向
  实例的原型，实例的__proto__属性也指向原型，实例会继承原型上属性和方法
  当访问实例上的属性时，会先在实例本身上去查找，若找不到会根据原型链
  找到实例的原型并在原型查找该属性，若还是找不到，则继续在原型的原型
  上去查找，直到找到Object构造函数，他的原型是null，最后结束查找，这一条查找的
  链路就是原型链。
  有哪些继承方法：
  1.创建构造函数的实例
  2.两个构造函数间继承
  3.es6 class 的 extends
  回答问题：没回答出【原型链继承】【借用构造函数继承】【组合继承】
  【原型式继承】【寄生式继承】【寄生组合式继承】

  《构造函数和类》



</body>

</html>
<script>
  function deepCopy(obj) {
    let result = Array.isArray(obj) ? [] : {}
    for (const key in obj) {
      if (Object.hasOwnProperty.call(obj, key)) {
        const item = obj[key];
        if (item && typeof item === 'object') {
          result[key] = deepCopy(item)
        } else {
          result[key] = item
        }
      }
    }
    return result
  }

  // console.log(deepCopy({
  //   a: {
  //     b: [], c: {
  //       b: 1,
  //       c: function () { },
  //       d: null,
  //       e: undefined,
  //       f: false,
  //       g: 'aa',
  //       h: []
  //     }
  //   },
  //   b: 1,
  //   c: function () { },
  //   d: null,
  //   e: undefined,
  //   f: false,
  //   g: 'aa',
  //   h: []
  // }))

  // 原型链继承
  function Parent() {
    this.sex = '男'
  }
  Parent.prototype.say = function () {
    console.log('hello');
  }

  function Child(age) {
    Parent.call(this)
    this.age = age
  }
  Child.prototype = new Parent()
  Child.prototype.sayAge = function () {
    console.log(this.age);
  }

  let c = new Child(10)
  console.log(c.sex); // 男
  console.log(c.age); // 10
  c.say() // hello
  c.sayAge() // 10

  // function createAnother(obj) {
  //   function F() { }
  //   F.prototype = obj
  //   return new F()
  // }

  // let c = createAnother(new Parent())
  // console.log(c.sex);
  // console.log(c.say());

  // function Child() {
  //   Parent.call(this)
  // }
  // Child.prototype = new Parent()

  // let c = new Child()
  // console.log(c.sex);
  // console.log(c.say());
  // console.log(Child.prototype.constructor);


  // let p = new Parent()
  // console.log(p instanceof Parent); // true
</script>