- [前言](#前言)
- [什么是DOCTYPE及作用](#什么是doctype及作用)
  - [定义](#定义)
  - [常见的DOCTYPE声明有几种](#常见的doctype声明有几种)
- [浏览器的渲染过程](#浏览器的渲染过程)
  - [渲染树](#渲染树)
  - [渲染过程（重要）](#渲染过程重要)
  - [关键渲染路径](#关键渲染路径)
- [Reflow：重排（回流）](#reflow重排回流)
  - [定义](#定义-1)
  - [什么时候会触发 Reflow](#什么时候会触发-reflow)
- [Repaint：重绘](#repaint重绘)
  - [定义](#定义-2)
  - [什么时候触发 Repaint](#什么时候触发-repaint)
- [拓展：从输入 URL 到页面加载完成的过程](#拓展从输入-url-到页面加载完成的过程)

## 前言

**渲染机制** 包括的内容：

  * 什么是DOCTYPE及作用

  * 浏览器渲染过程

面试经常会问：在浏览器中输入url，发生了哪些事情。其中有一部就是浏览器的渲染过程。

  * Reflow：重排

面试官问完了渲染机制，一般会紧接着问重排Reflow，你可千万别说你没听过。

  * Repaint：重绘

  * Layout：布局

这里的Layout指的是浏览器的Layout。

## 什么是DOCTYPE及作用

### 定义

**DTD** （Document Type Definition）：文档类型定义。

是一系列的语法规则，用来定义XML或者(X)HTML文件类型。 **浏览器会使用DTD来判断文本类型**
，决定使用何种协议来解析，以及切换浏览器模式。（说白了就是：DTD就是告诉浏览器，我是什么文档类型，你要用什么协议来解析我）

**DOCTYPE** ：用来声明DTD规范。

一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出现一些差错。（说白了，DOCTYPE就是用来声明DTD的）

### 常见的DOCTYPE声明有几种

> 面试官紧接着会问，常见的 DOCTYPE 有哪些，以及 HTML5 的 DOCTYPE 怎么写。

1、 **HTML 4.01 Strict** ：（严格的）

    
    
    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">

PS：该DTD包含所有的HTML元素和属性，但不包括展示性的和弃用的元素（比如 font、u下划线等，这些是被废弃了的）。

2、 **HTML 4.01 Transitional** ：（传统的）

    
    
    <!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">

PS：该DTD包含所有的HTML元素和属性，但包括展示性的和弃用的元素（比如 font、u下划线等）。

3、HTML 5：

    
    
    <!DOCTYPE html>

**总结：**

面试时，不会让你写出 HTML 4.01的写法，因为大家都记不住。但是要记住 HTML 5 的写法，别看它简单，知道的人还真不多。

面试时，可以这样回答： HTML 4.01 中有两种写法，一种是严格的，一种是传统的；并且答出二者的区别。 HTML 5的写法是`<!DOCTYPE
html>`。

## 浏览器的渲染过程

### 渲染树

[![](https://camo.githubusercontent.com/6061ff201656d4c8e211e20dd76816b1f552727c980a5231ad9ed5ca0a7cbb01/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303131382d323030352e706e67)](https://camo.githubusercontent.com/6061ff201656d4c8e211e20dd76816b1f552727c980a5231ad9ed5ca0a7cbb01/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303131382d323030352e706e67)

> 上方图片的来源：[Google 官方 |
> 渲染树构建、布局及绘制](https://developers.google.com/web/fundamentals/performance/critical-
> rendering-path/render-tree-construction?hl=zh-cn)

**渲染树** 包含了网页中有哪些节点、各个节点的CSS样式（大小、颜色等）、以及他们的从属关系。

我们写完前端代码之后，计算机通过解释器把代码文本翻译成机器能理解的数据结构。比如说，html标签是由一对一对的尖括号表述的，可以被浏览器解析为有含义的标记。这些标记被翻译成节点对象，存放到链型数据结构中。这些节点被称之为
**DOM对象** ，这个链型数据结构就是 **渲染树** 。

### 渲染过程（重要）

浏览器的渲染过程非常复杂，但是面试只用说几句话就行了，不然太耗时间。如何快速简洁地描述清楚，是关键。来看看下面这张图。

[![](https://camo.githubusercontent.com/822ccfe36ee7899aba1ad905f3f7da6bf02879034f40e60c6fb785619c07fbd8/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331305f313235372e706e67)](https://camo.githubusercontent.com/822ccfe36ee7899aba1ad905f3f7da6bf02879034f40e60c6fb785619c07fbd8/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331305f313235372e706e67)

这里解释一下几个概念，方便大家理解：

  * DOM树（DOM Tree）：浏览器将HTML标签解析成树形的数据结构。DOM树包含了有哪些节点，以及节点之间的嵌套关系。

  * CSSOM（CSS Rule Tree）：浏览器将CSS解析成树形的数据结构。CSSOM包含了节点的样式。

  * 渲染树（Render Tree）: DOM 树与 CSSOM 树合并后形成渲染树。渲染树只包含渲染网页所需的节点（但并不知道位置）。

  * 布局（Layout）: 计算出每个节点在屏幕中的 **位置和大小** 。

  * 绘制（Painting）：按照算出来的规则，通过显卡，把内容画出来。

  * conmposite：合成。浏览器在绘制的时候，不会把所有的内容都画在同一个层上。需要最终把这些层合成到一起，显示在屏幕上。

参考链接：

  * [浏览器渲染原理及流程](http://www.cnblogs.com/slly/p/6640761.html)

### 关键渲染路径

浏览器渲染分为五个阶段：

> JavaScript/CSS --> Style --> Layout --> Paint --> Composite

[![](https://camo.githubusercontent.com/9ea4650286a9c9f5726b2ee092f84d4100684702b1974c30374563291fe69044/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303131382d313935302e6a7067)](https://camo.githubusercontent.com/9ea4650286a9c9f5726b2ee092f84d4100684702b1974c30374563291fe69044/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303131382d313935302e6a7067)

>
> 上方图片的来源：<https://developers.google.com/web/fundamentals/performance/rendering>

关键渲染路径描述的是渲染从触发到绘制的全过程，一共经历了五个阶段：

（1）通过JS、CSS代码来 **触发** 页面上的视觉变化。

（2）Style：浏览器要重新对样式进行计算。

（3）layout：同上一段。

（4）painting：同上一段。

（5）conmposite：同上一段。

理论上，上面的五个步骤都是必须要经历的。布局和绘制是关键渲染路径中，最重要、开销最高的两个步骤。

但是，有些样式并不会影响布局，也不会影响绘制。所以，浏览器对这方面的性能进行了优化，并不一定要经历布局和绘制这两个过程。这就需要我们先了解一下「重排」和「重绘」这两个概念。详见下一段。

## Reflow：重排（回流）

### 定义

**重排 Reflow** ：

渲染对象在创建完成并添加到渲染树时，是将DOM节点和它对应的样式结合起来，并不包含位置和大小信息。

我们还需要通过 `Layout` 布局阶段，来计算它们在设备视口(viewport)内的确切位置和大小，计算这些值的过程称为`回流`、`布局`或`重排`。

参考链接：

  * [从浏览器渲染原理，浅谈回流重绘与性能优化](https://www.cnblogs.com/xiahj/p/11777786.html)

  * [你真的了解回流和重绘吗](https://github.com/chenjigeng/blog/issues/4)

### 什么时候会触发 Reflow

> 核心就是围绕DOM元素的 **大小** 和 **位置** 。

  * 增加、删除DOM节点

  * display: none

  * 移动元素位置，或是增加动画

  * 修改CSS样式时（宽高、display 为none等，都是通过css样式来修改的）

  * offsetLeft、scrollTop、clientWidth

  * 修改浏览器窗口大小时（即Resize窗口，移动端没有这个问题），或是滚动的时候， **有可能** 会触发（具体要看浏览器的规则）。

  * 修改网页的默认字体时（这个很消耗性能）。

**面试总结：**

首先要答出 Reflow 定义；其次，什么时候触发，至少要答出两条。更进一步，面试官可能还会问你 **怎么避免reflow** 

- 将元素设置 `position: fixed/absolute;` ；
- 添加多个元素时，提前将要添加元素准备好，仅插入一次；
- 添加一个类，样式都在类中修改
- 使用 `display:none` 不使用 `display: visible`

## Repaint：重绘

### 定义

**Repaint重绘制**
：当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器便把这些元素都按照各自的特性绘制一遍，于是页面的内容出现了，这个过程称之为
Repaint。

说白了，页面要呈现的内容，统统画在屏幕上，这就叫 Repaint。

### 什么时候触发 Repaint

  * DOM改动

  * CSS改动

其实，就是判断当前呈现的内容是否发生变化（无论这个变化是通过DOM改动还是CSS改动）。只要页面显示的内容不一样了，肯定要 Repaint。

**面试总结：**

面试官经常会问：“如何 **尽量减少** Repaint的频率？”

注意， reflow是问“怎么避免”，repaint是问“怎么减少”。Repaint是无法避免的，否则就成了静态页面了。

**答案** ：

（1）如果需要创建多个DOM节点，可以使用 **DocumentFragment**
创建完，然后一次性地加入document。（加一个节点，就repaint一次，不太好）

（2）将元素的display设置为”none”，完成修改后再把display修改为原来的值。

参考链接：[如何减少浏览器repaint和reflow
?](http://blog.csdn.net/liaozhongping/article/details/47057889)

## 拓展：从输入 URL 到页面加载完成的过程

1. 首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来
2. 接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了
3. TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据
4. 数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件
5. 首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错
6. 浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件
7. 文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。
8. 初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件
9. CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西
10. 在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了


**原文：**

https://github.com/qianguyihao/Web/blob/master/13-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/01-%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/09-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6.md