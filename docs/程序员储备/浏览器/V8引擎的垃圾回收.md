

## 为何需要垃圾回收

我们知道，在V8引擎逐行执行JavaScript代码的过程中，当遇到函数的情况时，会为其创建一个函数执行上下文(Context)环境并添加到调用堆栈的栈顶，函数的作用域(handleScope)中包含了该函数中声明的所有变量，当该函数执行完毕后，对应的执行上下文从栈顶弹出，函数的作用域会随之销毁，其包含的所有变量也会统一释放并被自动回收。试想如果在这个作用域被销毁的过程中，其中的变量不被回收，即持久占用内存，那么必然会导致内存暴增，从而引发内存泄漏导致程序的性能直线下降甚至崩溃，因此内存在使用完毕之后理当归还给操作系统以保证内存的重复利用。

> 这个过程就好比你向亲戚朋友借钱，借得多了却不按时归还，那么你再下次借钱的时候肯定没有那么顺利了，或者说你的亲戚朋友不愿意再借你了，导致你的手头有点儿紧(内存泄漏，性能下降)，所以说有借有还，再借不难嘛，毕竟出来混都是要还的。

## V8的垃圾回收策略

> V8的回收策略`分代式垃圾回收机制`：根据对象的存活时间对内存垃圾进行分代，不用分代采用不同回收算法。



V8引擎的堆结构组成中，主要分为`新生代`和`老生代`：

- `新生代(new_space)`：大多数的对象开始都会被分配在这里，这个区域相对较小但是垃圾回收特别频繁，该区域被分为两半，一半用来分配内存，另一半用于在垃圾回收时将需要保留的对象复制过来。

- `老生代(old_space)`：新生代中的对象在存活一段时间后就会被转移到老生代内存区，相对于新生代该内存区域的垃圾回收频率较低。老生代又分为`老生代指针区`和`老生代数据区`，前者包含大多数可能存在指向其他对象的指针的对象，后者只保存原始数据对象，这些对象没有指向其他对象的指针。



`新生代`主要用于存放存活时间较短的对象，垃圾回收过程中主要采用了`Scavenge`算法，这一种牺牲空间获取时间的算法，因为新生代内存中，大部分对象的生命周期较短，在时间效率上表现可观，所以还是比较适合这种算法。

`老生代`的垃圾回收主要使用算法`Mark-Sweep(标记清除)`和`Mark-Compact(标记整理)`来管理。



### 引用计数算法

在 `标记清除` 和 `标记整理` 之前，还有一种 `引用计数` 的算法：

> `引用计数`：看对象是否还有其他引用指向它，如果没有指向该对象的引用，则该对象会被视为垃圾并被垃圾回收器回收.

它的弊端是，当出现 `循环引用` 的场景，变量将无法释放：

```js
function foo() {
    let a = {};
    let b = {};
    a.a1 = b;
    b.b1 = a;
}
foo();
```

示例中，a 、b两个对象相互引用，foo 函数执行完毕后，在 `引用计数` 算法下变量a、b是无法释放的，所以截至2012年所有的现代浏览器均放弃了这种算法，采用了`标记清除` 和 `标记整理`算法。

### 标记清除算法

`Mark-Sweep(标记清除)`分为`标记`和`清除`两个阶段，在标记阶段会遍历堆中的所有对象，然后标记活着的对象，在清除阶段中，会将死亡的对象进行清除。

具体步骤：

1. 垃圾回收器会在内部构建一个`根列表`，用于从根节点出发去寻找那些可以被访问到的变量。比如在JavaScript中，`window`全局对象可以看成一个根节点。

2. 然后，垃圾回收器从所有根节点出发，遍历其可以访问到的子节点，并将其标记为活动的，根节点不能到达的地方即为非活动的，将会被视为垃圾。

3. 最后，垃圾回收器将会释放所有非活动的内存块，并将其归还给操作系统。

### 标记整理算法

`标记清除`存在`内存碎片 `问题，经历过一次标记清除后，内存空间可能会出现不连续的状态，因为我们所清理的对象的内存地址可能不是连续的，导致后面如果需要分配一个大对象而空闲内存不足以分配，就会提前触发垃圾回收。



`Mark-Compact(标记整理)`算法就是为了解决这个问题而提出的，该算法在回收过程中将死亡对象清除后，在整理的过程中，会将活动的对象往堆内存的一端进行移动，移动完成后再清理掉边界外的全部内存，从而避免了 `内存碎片`问题。

## 如何避免内存泄露

1. 避免创建全局变量

   挂载在 window 上的属性会被标记为活动的从而常驻内存。

   全局变量示例：

   ```js
   // 示例1
   var a = 1;
   
   // 示例2
   function demo() {
    	b = 2
   }
   ```

   如果不可避免使用到全局变量，那要在使用结束后将其设置为 null 触发回收。

   ```js
   a = null;
   ```

2. 手动清除计时器

   若在计时器中操作外部变量但未及时清除计时器，很有可能会导致内存泄露：

   ```js
   const numbers = [];
   const foo = function() {
       for(let i = 0;i < 100000;i++) {
           numbers.push(i);
       }
   };
   window.setInterval(foo, 1000);
   
   ```

3. 减少使用闭包

   闭包会导致被引用的变量无法释放，如下示例中 local 就会常驻内存中。

   ```js
   function foo() {
       let local = 123;
       return function() {
           return local;
       }
   }
   const bar = foo();
   console.log(bar()); // -> 123
   
   ```

   或者去掉匿名函数的引用亦可触发回收：

   ```js
   bar = null
   ```

4. 清除DOM的引用

   当把 DOM 存储于变量中， DOM 被删除后变量任然无法释放，如示例中 `elements.button` 任然存在。

   ```js
   const elements = {
       button: document.getElementById('button')
   };
   
   function removeButton() {
       document.body.removeChild(document.getElementById('button'));
   }
   removeButton()
   ```

   所以当 DOM 使用完毕，需将其至为 null 以触发回收：

   ```js
   elements.button = null
   ```

​		

## 后语

参考文章

[一文搞懂V8引擎的垃圾回收](https://juejin.cn/post/6844904016325902344#heading-3)
