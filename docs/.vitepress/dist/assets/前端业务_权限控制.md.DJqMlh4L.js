import{_ as s,c as i,o as a,a2 as e}from"./chunks/framework.Bek_Mmwg.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端业务/权限控制.md","filePath":"前端业务/权限控制.md"}'),t={name:"前端业务/权限控制.md"},p=e(`<h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p>前端权限控制是很有必要的</p><ul><li>减少请求次数降低服务器压力</li><li>二来用户可以更直观看到可操作项减少了无效操作提升用户体验</li></ul><p>当然了，前端的权限控制只是辅助，后端的权限控制才是主要的，目前较流行的Java权限控制库有 <code>spring security</code> 和 apache 的 <code>shiro</code> 。</p><p>该篇站在前端的角度，来说一说权限控制。</p><h2 id="接口权限" tabindex="-1">接口权限 <a class="header-anchor" href="#接口权限" aria-label="Permalink to &quot;接口权限&quot;">​</a></h2><p>接口权限控制一般采用 <code>jwt</code> 控制。</p><p><strong>何为 <code>jwt</code> ？</strong></p><p>全称为 <code>json web token</code> 。</p><ul><li>用户使用账号密码请求服务器授权</li><li>服务器校验通过后颁发 <code>token</code></li><li>客服端拿到 <code>token</code> 并存在 sessionStore 或 cookie 中</li><li>每次发送请求到服务器前将 <code>token</code> 设置在请求头一同发送（可在请求拦截中实现）</li><li>服务器验证 <code>token</code> 的有效性后处理或拒绝请求</li></ul><p>当服务器拒绝请求时会返回错误状态码，前端需根据不同错误状态码做相应错误处理。比如：错误状态码为 <code>401</code> 表示登录失败无访问权限，前端可将页面跳转到登录页并提示用户登录。</p><h2 id="按钮权限" tabindex="-1">按钮权限 <a class="header-anchor" href="#按钮权限" aria-label="Permalink to &quot;按钮权限&quot;">​</a></h2><p>按钮权限控制，一般要配合后端来实现。</p><ul><li>首先会有一个权限管理模块，用于配置有哪些角色，角色有哪些权限，再给用户指派角色</li><li>用户登录时请求服务拿到可操作按钮权限 key 列表，存起来</li><li>封装一个根据用户按钮权限控制按钮显示状态的指令，应用到权限按钮上</li></ul><p><strong>举例</strong></p><p>服务端返回按钮权限 key 列表，如：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">[</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;app:delete&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;app:edit&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">]</span></span></code></pre></div><p>app 表示某个功能的名称，而 : 后跟的是该功能对应的操作，我们可从这个列表知道该用户拥有 app 功能的删除和编辑权限。</p><p>实现一个 <code>v-anth</code> 指令，控制按钮显示状态</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> v-auth</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;app:delete&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;删除应用&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>这里不对 <code>v-auth</code> 实现多做赘述，主要逻辑就是判断按钮权限 key 列表是否存在该权限，然后用 v-if 或 disabled 控制按钮显示状态。</p><h2 id="页面权限" tabindex="-1">页面权限 <a class="header-anchor" href="#页面权限" aria-label="Permalink to &quot;页面权限&quot;">​</a></h2><p>页面访问权限也需要后端配合。</p><ul><li>需要有一个菜单权限管理模块，可动态更改角色菜单访问权限，给用户分配角色</li><li>客户端拿到可访问菜单列表，搭配组件动态注入 Router，并根据列表渲染菜单列表</li></ul><p>服务端需返回类似如下菜单数据</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:xxx</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  path</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:xxx</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  meta</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          role</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [xxx,xxx,xxx] </span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//哪些角色有资格</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          MenuIcon</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;xxxx&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  //菜单图标</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">          MenuTitle</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&#39;xxx&#39;</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;"> //菜单名</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">      }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>前端需将数据格式转化为 Router 支持的菜单格式，并将与菜单一一对应 component 引入，处理完成后注入路由。这样处理后，路由就不会有冗余组件，用户也无法输入地址来访问无权限的路由。</p>`,27),l=[p];function n(h,k,d,o,r,c){return a(),i("div",null,l)}const u=s(t,[["render",n]]);export{g as __pageData,u as default};
