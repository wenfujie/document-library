import{_ as e,c as a,o as t,a2 as i}from"./chunks/framework.Bek_Mmwg.js";const o="/assets/vite%E5%92%8C%E4%BC%A0%E7%BB%9F%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7%E5%86%B7%E5%90%AF%E5%8A%A8%E5%AF%B9%E6%AF%94.DaoUCO2S.jpg",v=JSON.parse('{"title":"vite为何冷启动、热更快？","description":"","frontmatter":{},"headers":[],"relativePath":"前端工程化/构建/vite/vite为何冷启动、热更快.md","filePath":"前端工程化/构建/vite/vite为何冷启动、热更快.md"}'),l={name:"前端工程化/构建/vite/vite为何冷启动、热更快.md"},s=i('<h1 id="vite为何冷启动、热更快" tabindex="-1">vite为何冷启动、热更快？ <a class="header-anchor" href="#vite为何冷启动、热更快" aria-label="Permalink to &quot;vite为何冷启动、热更快？&quot;">​</a></h1><h2 id="如何做到冷启动快" tabindex="-1">如何做到冷启动快？ <a class="header-anchor" href="#如何做到冷启动快" aria-label="Permalink to &quot;如何做到冷启动快？&quot;">​</a></h2><ol><li>vite 以原生 <code>ESM 方式</code> 并 <code>按需构建</code> 业务代码。</li><li>使用 Esbuild 对依赖进行预构建。</li></ol><p>第一点意旨，因为使用 <code>ESM</code> 方式， vite 支持了 <code>按需构建</code>，即在浏览器运行到某个模块时 vite 才会对该模块代码转换和响应，节省了冷启动时对全量代码构建时间。</p><p><img src="'+o+'" alt=""></p><h3 id="什么是预构建" tabindex="-1">什么是预构建？ <a class="header-anchor" href="#什么是预构建" aria-label="Permalink to &quot;什么是预构建？&quot;">​</a></h3><p>预构建用于解决引入三方依赖的两个问题：</p><ol><li>提前将依赖转换成 ESM 模块。</li><li>合并包的二次依赖。</li></ol><p>其中第二点，以 lodash 举例，lodash 依赖许多库，预构建时就会把这些库都请求并组成一个文件，避免了在项目启动后加载 lodash 时会发起多个请求。</p><h3 id="为什么-esbuild-效率这么高" tabindex="-1">为什么 Esbuild 效率这么高？ <a class="header-anchor" href="#为什么-esbuild-效率这么高" aria-label="Permalink to &quot;为什么 Esbuild 效率这么高？&quot;">​</a></h3><p>Esbuild 在构建速度上比传统工具快 10~100 倍。那么，它是如何达到这样超高的构建性能的呢？</p><p>主要原因可以概括为 4 点</p><ol><li>使用 Golang 开发，构建逻辑代码直接被编译为原生机器码，而不用像 JS 一样先代码解析为字节码，然后转换为机器码，大大节省了程序运行时间。</li><li>多核并行。内部打包算法充分利用多核 CPU 优势，所有的步骤尽可能并行，这也是得益于 Go 当中多线程共享内存的优势。</li><li>从零造轮子。 几乎没有使用任何第三方库，所有逻辑自己编写，大到 AST 解析，小到字符串的操作，保证极致的代码性能。</li><li>高效的内存利用。Esbuild 中从头到尾尽可能地复用一份 AST 节点数据，而不用像 JS 打包工具中频繁地解析和传递 AST 数据（如 string -&gt; TS -&gt; JS -&gt; string），造成内存的大量浪费。</li></ol><h2 id="如何做到热更新快" tabindex="-1">如何做到热更新快？ <a class="header-anchor" href="#如何做到热更新快" aria-label="Permalink to &quot;如何做到热更新快？&quot;">​</a></h2><p>webpack 为什么热更慢？因为只要开发时改动了代码，就会触发项目所有代码重新打包，随着项目迭代依赖增加，热更只会越来越慢。</p><p>在 vite 中，代码变化时，vite 会定位到发生变化的局部模块，也就是找到 <code>HMR</code> 的边界，基于这个边界去更新，其他模块不会受到影响。</p>',16),d=[s];function r(c,_,n,h,p,u){return t(),a("div",null,d)}const b=e(l,[["render",r]]);export{v as __pageData,b as default};
