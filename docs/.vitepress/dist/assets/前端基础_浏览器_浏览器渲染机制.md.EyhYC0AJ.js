import{_ as e,c as a,o as t,a2 as l}from"./chunks/framework.Bek_Mmwg.js";const g=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端基础/浏览器/浏览器渲染机制.md","filePath":"前端基础/浏览器/浏览器渲染机制.md"}'),o={name:"前端基础/浏览器/浏览器渲染机制.md"},r=l(`<ul><li><a href="#前言">前言</a></li><li><a href="#什么是doctype及作用">什么是DOCTYPE及作用</a><ul><li><a href="#定义">定义</a></li><li><a href="#常见的doctype声明有几种">常见的DOCTYPE声明有几种</a></li></ul></li><li><a href="#浏览器的渲染过程">浏览器的渲染过程</a><ul><li><a href="#渲染树">渲染树</a></li><li><a href="#渲染过程重要">渲染过程（重要）</a></li><li><a href="#关键渲染路径">关键渲染路径</a></li></ul></li><li><a href="#reflow重排回流">Reflow：重排（回流）</a><ul><li><a href="#定义-1">定义</a></li><li><a href="#什么时候会触发-reflow">什么时候会触发 Reflow</a></li></ul></li><li><a href="#repaint重绘">Repaint：重绘</a><ul><li><a href="#定义-2">定义</a></li><li><a href="#什么时候触发-repaint">什么时候触发 Repaint</a></li></ul></li><li><a href="#拓展从输入-url-到页面加载完成的过程">拓展：从输入 URL 到页面加载完成的过程</a></li></ul><h2 id="前言" tabindex="-1">前言 <a class="header-anchor" href="#前言" aria-label="Permalink to &quot;前言&quot;">​</a></h2><p><strong>渲染机制</strong> 包括的内容：</p><ul><li><p>什么是DOCTYPE及作用</p></li><li><p>浏览器渲染过程</p></li></ul><p>面试经常会问：在浏览器中输入url，发生了哪些事情。其中有一部就是浏览器的渲染过程。</p><ul><li>Reflow：重排</li></ul><p>面试官问完了渲染机制，一般会紧接着问重排Reflow，你可千万别说你没听过。</p><ul><li><p>Repaint：重绘</p></li><li><p>Layout：布局</p></li></ul><p>这里的Layout指的是浏览器的Layout。</p><h2 id="什么是doctype及作用" tabindex="-1">什么是DOCTYPE及作用 <a class="header-anchor" href="#什么是doctype及作用" aria-label="Permalink to &quot;什么是DOCTYPE及作用&quot;">​</a></h2><h3 id="定义" tabindex="-1">定义 <a class="header-anchor" href="#定义" aria-label="Permalink to &quot;定义&quot;">​</a></h3><p><strong>DTD</strong> （Document Type Definition）：文档类型定义。</p><p>是一系列的语法规则，用来定义XML或者(X)HTML文件类型。 <strong>浏览器会使用DTD来判断文本类型</strong> ，决定使用何种协议来解析，以及切换浏览器模式。（说白了就是：DTD就是告诉浏览器，我是什么文档类型，你要用什么协议来解析我）</p><p><strong>DOCTYPE</strong> ：用来声明DTD规范。</p><p>一个主要的用途便是文件的合法性验证。如果文件代码不合法，那么浏览器解析时便会出现一些差错。（说白了，DOCTYPE就是用来声明DTD的）</p><h3 id="常见的doctype声明有几种" tabindex="-1">常见的DOCTYPE声明有几种 <a class="header-anchor" href="#常见的doctype声明有几种" aria-label="Permalink to &quot;常见的DOCTYPE声明有几种&quot;">​</a></h3><blockquote><p>面试官紧接着会问，常见的 DOCTYPE 有哪些，以及 HTML5 的 DOCTYPE 怎么写。</p></blockquote><p>1、 <strong>HTML 4.01 Strict</strong> ：（严格的）</p><pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt;
</code></pre><p>PS：该DTD包含所有的HTML元素和属性，但不包括展示性的和弃用的元素（比如 font、u下划线等，这些是被废弃了的）。</p><p>2、 <strong>HTML 4.01 Transitional</strong> ：（传统的）</p><pre><code>&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;
</code></pre><p>PS：该DTD包含所有的HTML元素和属性，但包括展示性的和弃用的元素（比如 font、u下划线等）。</p><p>3、HTML 5：</p><pre><code>&lt;!DOCTYPE html&gt;
</code></pre><p><strong>总结：</strong></p><p>面试时，不会让你写出 HTML 4.01的写法，因为大家都记不住。但是要记住 HTML 5 的写法，别看它简单，知道的人还真不多。</p><p>面试时，可以这样回答： HTML 4.01 中有两种写法，一种是严格的，一种是传统的；并且答出二者的区别。 HTML 5的写法是<code>&lt;!DOCTYPE html&gt;</code>。</p><h2 id="浏览器的渲染过程" tabindex="-1">浏览器的渲染过程 <a class="header-anchor" href="#浏览器的渲染过程" aria-label="Permalink to &quot;浏览器的渲染过程&quot;">​</a></h2><h3 id="渲染树" tabindex="-1">渲染树 <a class="header-anchor" href="#渲染树" aria-label="Permalink to &quot;渲染树&quot;">​</a></h3><p><a href="https://camo.githubusercontent.com/6061ff201656d4c8e211e20dd76816b1f552727c980a5231ad9ed5ca0a7cbb01/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303131382d323030352e706e67" target="_blank" rel="noreferrer"><img src="https://camo.githubusercontent.com/6061ff201656d4c8e211e20dd76816b1f552727c980a5231ad9ed5ca0a7cbb01/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303131382d323030352e706e67" alt=""></a></p><blockquote><p>上方图片的来源：[Google 官方 | 渲染树构建、布局及绘制](<a href="https://developers.google.com/web/fundamentals/performance/critical-" target="_blank" rel="noreferrer">https://developers.google.com/web/fundamentals/performance/critical-</a> rendering-path/render-tree-construction?hl=zh-cn)</p></blockquote><p><strong>渲染树</strong> 包含了网页中有哪些节点、各个节点的CSS样式（大小、颜色等）、以及他们的从属关系。</p><p>我们写完前端代码之后，计算机通过解释器把代码文本翻译成机器能理解的数据结构。比如说，html标签是由一对一对的尖括号表述的，可以被浏览器解析为有含义的标记。这些标记被翻译成节点对象，存放到链型数据结构中。这些节点被称之为 <strong>DOM对象</strong> ，这个链型数据结构就是 <strong>渲染树</strong> 。</p><h3 id="渲染过程-重要" tabindex="-1">渲染过程（重要） <a class="header-anchor" href="#渲染过程-重要" aria-label="Permalink to &quot;渲染过程（重要）&quot;">​</a></h3><p>浏览器的渲染过程非常复杂，但是面试只用说几句话就行了，不然太耗时间。如何快速简洁地描述清楚，是关键。来看看下面这张图。</p><p><a href="https://camo.githubusercontent.com/822ccfe36ee7899aba1ad905f3f7da6bf02879034f40e60c6fb785619c07fbd8/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331305f313235372e706e67" target="_blank" rel="noreferrer"><img src="https://camo.githubusercontent.com/822ccfe36ee7899aba1ad905f3f7da6bf02879034f40e60c6fb785619c07fbd8/687474703a2f2f696d672e736d79687661652e636f6d2f32303138303331305f313235372e706e67" alt=""></a></p><p>这里解释一下几个概念，方便大家理解：</p><ul><li><p>DOM树（DOM Tree）：浏览器将HTML标签解析成树形的数据结构。DOM树包含了有哪些节点，以及节点之间的嵌套关系。</p></li><li><p>CSSOM（CSS Rule Tree）：浏览器将CSS解析成树形的数据结构。CSSOM包含了节点的样式。</p></li><li><p>渲染树（Render Tree）: DOM 树与 CSSOM 树合并后形成渲染树。渲染树只包含渲染网页所需的节点（但并不知道位置）。</p></li><li><p>布局（Layout）: 计算出每个节点在屏幕中的 <strong>位置和大小</strong> 。</p></li><li><p>绘制（Painting）：按照算出来的规则，通过显卡，把内容画出来。</p></li><li><p>conmposite：合成。浏览器在绘制的时候，不会把所有的内容都画在同一个层上。需要最终把这些层合成到一起，显示在屏幕上。</p></li></ul><p>参考链接：</p><ul><li><a href="http://www.cnblogs.com/slly/p/6640761.html" target="_blank" rel="noreferrer">浏览器渲染原理及流程</a></li></ul><h3 id="关键渲染路径" tabindex="-1">关键渲染路径 <a class="header-anchor" href="#关键渲染路径" aria-label="Permalink to &quot;关键渲染路径&quot;">​</a></h3><p>浏览器渲染分为五个阶段：</p><blockquote><p>JavaScript/CSS --&gt; Style --&gt; Layout --&gt; Paint --&gt; Composite</p></blockquote><p><a href="https://camo.githubusercontent.com/9ea4650286a9c9f5726b2ee092f84d4100684702b1974c30374563291fe69044/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303131382d313935302e6a7067" target="_blank" rel="noreferrer"><img src="https://camo.githubusercontent.com/9ea4650286a9c9f5726b2ee092f84d4100684702b1974c30374563291fe69044/687474703a2f2f696d672e736d79687661652e636f6d2f32303231303131382d313935302e6a7067" alt=""></a></p><blockquote><p>上方图片的来源：<a href="https://developers.google.com/web/fundamentals/performance/rendering" target="_blank" rel="noreferrer">https://developers.google.com/web/fundamentals/performance/rendering</a></p></blockquote><p>关键渲染路径描述的是渲染从触发到绘制的全过程，一共经历了五个阶段：</p><p>（1）通过JS、CSS代码来 <strong>触发</strong> 页面上的视觉变化。</p><p>（2）Style：浏览器要重新对样式进行计算。</p><p>（3）layout：同上一段。</p><p>（4）painting：同上一段。</p><p>（5）conmposite：同上一段。</p><p>理论上，上面的五个步骤都是必须要经历的。布局和绘制是关键渲染路径中，最重要、开销最高的两个步骤。</p><p>但是，有些样式并不会影响布局，也不会影响绘制。所以，浏览器对这方面的性能进行了优化，并不一定要经历布局和绘制这两个过程。这就需要我们先了解一下「重排」和「重绘」这两个概念。详见下一段。</p><h2 id="reflow-重排-回流" tabindex="-1">Reflow：重排（回流） <a class="header-anchor" href="#reflow-重排-回流" aria-label="Permalink to &quot;Reflow：重排（回流）&quot;">​</a></h2><h3 id="定义-1" tabindex="-1">定义 <a class="header-anchor" href="#定义-1" aria-label="Permalink to &quot;定义&quot;">​</a></h3><p><strong>重排 Reflow</strong> ：</p><p>渲染对象在创建完成并添加到渲染树时，是将DOM节点和它对应的样式结合起来，并不包含位置和大小信息。</p><p>我们还需要通过 <code>Layout</code> 布局阶段，来计算它们在设备视口(viewport)内的确切位置和大小，计算这些值的过程称为<code>回流</code>、<code>布局</code>或<code>重排</code>。</p><p>参考链接：</p><ul><li><p><a href="https://www.cnblogs.com/xiahj/p/11777786.html" target="_blank" rel="noreferrer">从浏览器渲染原理，浅谈回流重绘与性能优化</a></p></li><li><p><a href="https://github.com/chenjigeng/blog/issues/4" target="_blank" rel="noreferrer">你真的了解回流和重绘吗</a></p></li></ul><h3 id="什么时候会触发-reflow" tabindex="-1">什么时候会触发 Reflow <a class="header-anchor" href="#什么时候会触发-reflow" aria-label="Permalink to &quot;什么时候会触发 Reflow&quot;">​</a></h3><blockquote><p>核心就是围绕DOM元素的 <strong>大小</strong> 和 <strong>位置</strong> 。</p></blockquote><ul><li><p>增加、删除DOM节点</p></li><li><p>display: none</p></li><li><p>移动元素位置，或是增加动画</p></li><li><p>修改CSS样式时（宽高、display 为none等，都是通过css样式来修改的）</p></li><li><p>offsetLeft、scrollTop、clientWidth</p></li><li><p>修改浏览器窗口大小时（即Resize窗口，移动端没有这个问题），或是滚动的时候， <strong>有可能</strong> 会触发（具体要看浏览器的规则）。</p></li><li><p>修改网页的默认字体时（这个很消耗性能）。</p></li></ul><p><strong>面试总结：</strong></p><p>首先要答出 Reflow 定义；其次，什么时候触发，至少要答出两条。更进一步，面试官可能还会问你 <strong>怎么避免reflow</strong></p><ul><li>将元素设置 <code>position: fixed/absolute;</code> ；</li><li>添加多个元素时，提前将要添加元素准备好，仅插入一次；</li><li>添加一个类，样式都在类中修改</li><li>使用 <code>display:none</code> 不使用 <code>display: visible</code></li></ul><h2 id="repaint-重绘" tabindex="-1">Repaint：重绘 <a class="header-anchor" href="#repaint-重绘" aria-label="Permalink to &quot;Repaint：重绘&quot;">​</a></h2><h3 id="定义-2" tabindex="-1">定义 <a class="header-anchor" href="#定义-2" aria-label="Permalink to &quot;定义&quot;">​</a></h3><p><strong>Repaint重绘制</strong> ：当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来后，浏览器便把这些元素都按照各自的特性绘制一遍，于是页面的内容出现了，这个过程称之为 Repaint。</p><p>说白了，页面要呈现的内容，统统画在屏幕上，这就叫 Repaint。</p><h3 id="什么时候触发-repaint" tabindex="-1">什么时候触发 Repaint <a class="header-anchor" href="#什么时候触发-repaint" aria-label="Permalink to &quot;什么时候触发 Repaint&quot;">​</a></h3><ul><li><p>DOM改动</p></li><li><p>CSS改动</p></li></ul><p>其实，就是判断当前呈现的内容是否发生变化（无论这个变化是通过DOM改动还是CSS改动）。只要页面显示的内容不一样了，肯定要 Repaint。</p><p><strong>面试总结：</strong></p><p>面试官经常会问：“如何 <strong>尽量减少</strong> Repaint的频率？”</p><p>注意， reflow是问“怎么避免”，repaint是问“怎么减少”。Repaint是无法避免的，否则就成了静态页面了。</p><p><strong>答案</strong> ：</p><p>（1）如果需要创建多个DOM节点，可以使用 <strong>DocumentFragment</strong> 创建完，然后一次性地加入document。（加一个节点，就repaint一次，不太好）</p><p>（2）将元素的display设置为”none”，完成修改后再把display修改为原来的值。</p><p>参考链接：<a href="http://blog.csdn.net/liaozhongping/article/details/47057889" target="_blank" rel="noreferrer">如何减少浏览器repaint和reflow ?</a></p><h2 id="拓展-从输入-url-到页面加载完成的过程" tabindex="-1">拓展：从输入 URL 到页面加载完成的过程 <a class="header-anchor" href="#拓展-从输入-url-到页面加载完成的过程" aria-label="Permalink to &quot;拓展：从输入 URL 到页面加载完成的过程&quot;">​</a></h2><ol><li>首先做 DNS 查询，如果这一步做了智能 DNS 解析的话，会提供访问速度最快的 IP 地址回来</li><li>接下来是 TCP 握手，应用层会下发数据给传输层，这里 TCP 协议会指明两端的端口号，然后下发给网络层。网络层中的 IP 协议会确定 IP 地址，并且指示了数据传输中如何跳转路由器。然后包会再被封装到数据链路层的数据帧结构中，最后就是物理层面的传输了</li><li>TCP 握手结束后会进行 TLS 握手，然后就开始正式的传输数据</li><li>数据在进入服务端之前，可能还会先经过负责负载均衡的服务器，它的作用就是将请求合理的分发到多台服务器上，这时假设服务端会响应一个 HTML 文件</li><li>首先浏览器会判断状态码是什么，如果是 200 那就继续解析，如果 400 或 500 的话就会报错，如果 300 的话会进行重定向，这里会有个重定向计数器，避免过多次的重定向，超过次数也会报错</li><li>浏览器开始解析文件，如果是 gzip 格式的话会先解压一下，然后通过文件的编码格式知道该如何去解码文件</li><li>文件解码成功后会正式开始渲染流程，先会根据 HTML 构建 DOM 树，有 CSS 的话会去构建 CSSOM 树。如果遇到 script 标签的话，会判断是否存在 async 或者 defer ，前者会并行进行下载并执行 JS，后者会先下载文件，然后等待 HTML 解析完成后顺序执行，如果以上都没有，就会阻塞住渲染流程直到 JS 执行完毕。遇到文件下载的会去下载文件，这里如果使用 HTTP 2.0 协议的话会极大的提高多图的下载效率。</li><li>初始的 HTML 被完全加载和解析后会触发 DOMContentLoaded 事件</li><li>CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，这一步就是确定页面元素的布局、样式等等诸多方面的东西</li><li>在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上了</li></ol><p><strong>原文：</strong></p><p><a href="https://github.com/qianguyihao/Web/blob/master/13-%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95/01-%E9%9D%A2%E8%AF%95%E5%BF%85%E7%9C%8B/09-%E6%B5%8F%E8%A7%88%E5%99%A8%E6%B8%B2%E6%9F%93%E6%9C%BA%E5%88%B6.md" target="_blank" rel="noreferrer">https://github.com/qianguyihao/Web/blob/master/13-前端面试/01-面试必看/09-浏览器渲染机制.md</a></p>`,85),i=[r];function p(n,c,s,d,h,f){return t(),a("div",null,i)}const b=e(o,[["render",p]]);export{g as __pageData,b as default};
