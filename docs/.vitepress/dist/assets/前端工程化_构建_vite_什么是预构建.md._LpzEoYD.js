import{_ as s,c as i,o as a,a2 as e}from"./chunks/framework.Bek_Mmwg.js";const t="/assets/%E4%BA%8C%E6%AC%A1%E6%9E%84%E5%BB%BA.BgG0AIXH.jpg",u=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端工程化/构建/vite/什么是预构建.md","filePath":"前端工程化/构建/vite/什么是预构建.md"}'),n={name:"前端工程化/构建/vite/什么是预构建.md"},l=e(`<h2 id="什么是预构建" tabindex="-1">什么是预构建？ <a class="header-anchor" href="#什么是预构建" aria-label="Permalink to &quot;什么是预构建？&quot;">​</a></h2><p>本地开发冷启动项目时，vite 需要预构建。</p><p>预构建用于解决引入三方依赖的两个问题：</p><ol><li>提前将依赖转换成 ESM 模块。</li><li>合并包的二次依赖。</li></ol><p>其中第二点，以 lodash 举例，lodash 依赖许多库，预构建时就会把这些库都请求并组成一个文件，避免了在项目启动后加载 lodash 时会发起多个请求。</p><h2 id="开启预构建" tabindex="-1">开启预构建 <a class="header-anchor" href="#开启预构建" aria-label="Permalink to &quot;开启预构建&quot;">​</a></h2><p>vite 中，默认会开启预构建，首次冷启动项目成功后，目录下的 node_modules 中发现.vite 目录，这就是预构建产物文件存放的目录。</p><p>浏览器访问项目时，可在控制台看到请求依赖的路径被重写成</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">http</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">:</span><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">//localhost:3001/node_modules/.vite/xxx.js?xxx</span></span></code></pre></div><h2 id="缓存机制" tabindex="-1">缓存机制 <a class="header-anchor" href="#缓存机制" aria-label="Permalink to &quot;缓存机制&quot;">​</a></h2><p>请求依赖时 http 请求会自动设置强缓存，过期时间为 1 年，当出现以下情况缓存才会失效：</p><ol><li>package.json 的 dependencies 字段</li><li>各种包管理器的 lock 文件</li><li>optimizeDeps 配置内容</li></ol><p>少部分场景不希望使用缓存时，可以这样做</p><ol><li>删除 <code>node_modules/.vite</code></li><li>在 Vite 配置文件中，将 server.force 设为 true。（server.force 为 Vite 2.0 版本，Vite 3.0 之后调整为 optimizeDeps.force）</li><li>命令行执行 npx vite --force 或者 npx vite optimize。</li></ol><h2 id="自定义配置" tabindex="-1">自定义配置 <a class="header-anchor" href="#自定义配置" aria-label="Permalink to &quot;自定义配置&quot;">​</a></h2><p><a href="https://cn.vitejs.dev/config/dep-optimization-options.html" target="_blank" rel="noreferrer">预配置选项 optimizeDeps 官方描述</a></p><p>其中 include、exclude 较为常用。</p><p>force 用于强制开启预构建，让缓存失效。</p><h3 id="optimizedeps-include" tabindex="-1">optimizeDeps.include <a class="header-anchor" href="#optimizedeps-include" aria-label="Permalink to &quot;optimizeDeps.include&quot;">​</a></h3><p>默认情况下，不在 node_modules 中的，链接的包不会被预构建。使用此选项可强制预构建链接的包。</p><p><strong>使用场景一：动态加载</strong></p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// src/locales/zh_CN.js</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> objectAssign </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;"> &quot;object-assign&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(objectAssign);</span></span>
<span class="line"></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// main.tsx</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> importModule</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">m</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> import</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">\`./locales/\${</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">m</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">}.ts\`</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">importModule</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;zh_CN&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">);</span></span></code></pre></div><p>该段代码中，对 <code>src/locales/zh_CN.js</code> 的引用为动态加载，vite 是识别不到要对 <code>object-assign</code> 包进行预构建的。</p><p>触发了 <code>二次构建</code> ：</p><p><img src="`+t+`" alt=""></p><p><code>二次构建</code> 的成本也比较大。不仅需要把预构建的流程重新运行一遍，还得重新刷新页面，并且需要重新请求所有的模块。尤其是在大型项目中，这个过程会严重拖慢应用的加载速度！因此，我们要尽力避免运行时的二次预构建。</p><p>具体做法通过 include 参数提前声明需要按需加载的依赖:</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// vite.config.ts</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">{</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  optimizeDeps</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">    include</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: [</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">      // 按需加载的依赖都可以声明到这个数组里</span></span>
<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">      &quot;object-assign&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">,</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    ];</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div>`,28),p=[l];function h(o,k,d,r,c,E){return a(),i("div",null,p)}const y=s(n,[["render",h]]);export{u as __pageData,y as default};
