import{_ as e,c as a,o,a2 as i}from"./chunks/framework.Bek_Mmwg.js";const t="/assets/vue2-catalog.CncNXVtQ.png",l="/assets/vue3-catalog.CyDiHMk1.png",v=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"前端框架/vue3/vue3设计和原理/Vue3做了哪些优化.md","filePath":"前端框架/vue3/vue3设计和原理/Vue3做了哪些优化.md"}'),r={name:"前端框架/vue3/vue3设计和原理/Vue3做了哪些优化.md"},n=i('<h2 id="_1-源码优化" tabindex="-1">1. 源码优化 <a class="header-anchor" href="#_1-源码优化" aria-label="Permalink to &quot;1. 源码优化&quot;">​</a></h2><h3 id="_1-1-monorepo-管理的优势" tabindex="-1">1.1 monorepo 管理的优势 <a class="header-anchor" href="#_1-1-monorepo-管理的优势" aria-label="Permalink to &quot;1.1 monorepo 管理的优势&quot;">​</a></h3><p>vue2 源码放在 src 目录下，依据功能拆分如图所示模块</p><img src="'+t+'" alt="vue2源码目录" style="zoom:30%;"><p>vue3 源码通过 monorepo 管理，依据功能拆分如图所示模块</p><img src="'+l+'" alt="vue3源码目录" style="zoom:30%;"><p>Monorepo 相对 vue2 的管理</p><ol><li>各个模块变得相互独立，各自有各自的类型定义、测试模块、Api，职责划分明确，代码可读性、可维护性更高</li><li>可单独引入某个包（例如 reactivity），减小引用包体积大小</li></ol><h3 id="_1-2-源码使用-ts-开发的优势" tabindex="-1">1.2 源码使用 ts 开发的优势 <a class="header-anchor" href="#_1-2-源码使用-ts-开发的优势" aria-label="Permalink to &quot;1.2 源码使用 ts 开发的优势&quot;">​</a></h3><ol><li>提供了类型检查</li><li>源码更易阅读</li><li>不用再单独维护 d.ts 声明文件</li></ol><h2 id="_2-性能" tabindex="-1">2.性能 <a class="header-anchor" href="#_2-性能" aria-label="Permalink to &quot;2.性能&quot;">​</a></h2><h3 id="_2-1-减小源码体积" tabindex="-1">2.1 减小源码体积 <a class="header-anchor" href="#_2-1-减小源码体积" aria-label="Permalink to &quot;2.1 减小源码体积&quot;">​</a></h3><ol><li>移除冷门 feture（比如 filter、inline-template 等）；</li><li>使用 tree-shaking ，减小打包体积</li></ol><h3 id="_2-2-数据劫持优化" tabindex="-1">2.2 数据劫持优化 <a class="header-anchor" href="#_2-2-数据劫持优化" aria-label="Permalink to &quot;2.2 数据劫持优化&quot;">​</a></h3><p>Vue2 中使用 Object.defineProperty 进行数据劫持，由于它只能对具体的key进行劫持，vue2深度遍历了data中的所有属性并对他们进行劫持，存在性能浪费。</p><p>Vue3 用 proxy 代替 Object.defineProperty 来实现数据劫持，proxy 支持对整个对象进行劫持，提升了性能。</p><h3 id="_2-3-编译优化" tabindex="-1">2.3 编译优化 <a class="header-anchor" href="#_2-3-编译优化" aria-label="Permalink to &quot;2.3 编译优化&quot;">​</a></h3><ol><li>Vue2 的更新效率与模板整体大小相关，而 vue3 缩小至与模板中动态内容的数量相关</li><li>Slot 的编译优化、事件侦听函数的缓存优化，并且在运行时重写了 diff 算法</li></ol><h2 id="_3-语法-api" tabindex="-1">3. 语法 api <a class="header-anchor" href="#_3-语法-api" aria-label="Permalink to &quot;3. 语法 api&quot;">​</a></h2><h3 id="_3-1-composition-api" tabindex="-1">3.1 Composition Api <a class="header-anchor" href="#_3-1-composition-api" aria-label="Permalink to &quot;3.1 Composition Api&quot;">​</a></h3><ol><li>逻辑代码更集中，更易阅读和维护：相比 vue2 中在大型组件中上下切换来查询 options，vue3 单个业务的状态及方法包裹在一个函数中，逻辑更聚合</li><li>代码复用性高：vue2 通过 Mixins 实现复用而产生的命名冲突、状态无法追踪等问题一并得以解决</li></ol>',21),s=[n];function _(h,c,p,u,d,m){return o(),a("div",null,s)}const b=e(r,[["render",_]]);export{v as __pageData,b as default};
