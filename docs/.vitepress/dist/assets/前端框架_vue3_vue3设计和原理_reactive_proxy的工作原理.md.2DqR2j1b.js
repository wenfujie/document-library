import{_ as t,c as e,o as a,a2 as s}from"./chunks/framework.Bek_Mmwg.js";const k=JSON.parse('{"title":"proxy 的工作原理","description":"","frontmatter":{},"headers":[],"relativePath":"前端框架/vue3/vue3设计和原理/reactive/proxy的工作原理.md","filePath":"前端框架/vue3/vue3设计和原理/reactive/proxy的工作原理.md"}'),i={name:"前端框架/vue3/vue3设计和原理/reactive/proxy的工作原理.md"},l=s(`<h1 id="proxy-的工作原理" tabindex="-1">proxy 的工作原理 <a class="header-anchor" href="#proxy-的工作原理" aria-label="Permalink to &quot;proxy 的工作原理&quot;">​</a></h1><h2 id="对象的内部方法" tabindex="-1">对象的内部方法 <a class="header-anchor" href="#对象的内部方法" aria-label="Permalink to &quot;对象的内部方法&quot;">​</a></h2><p>js 中，对象的语义是由对象的 <code>内部方法</code> 指定的。<code>内部方法</code> 指的是当我们对一个对象进行操作时在引擎内部调用的方法，并且这些方法对 js 使用者来说是不可见的。</p><p>举例说明</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">obj.foo;</span></span></code></pre></div><p>引擎内部会调用 <code>[[Get]]</code> 这个内部方法来读取属性值。</p><p>以下是对象部分 <code>内部方法</code></p><table><thead><tr><th style="text-align:left;">左对齐</th><th style="text-align:right;">右对齐</th><th style="text-align:center;">居中对齐</th></tr></thead><tbody><tr><td style="text-align:left;">[[Get]]</td><td style="text-align:right;">(propertyKey, Receiver) =&gt; any</td><td style="text-align:center;">获取属性值</td></tr><tr><td style="text-align:left;">[[Set]]</td><td style="text-align:right;">(propertyKey, value, Receiver) =&gt; Boolean</td><td style="text-align:center;">设置属性值</td></tr><tr><td style="text-align:left;">[[Delete]]</td><td style="text-align:right;">(propertyKey) =&gt; Boolean</td><td style="text-align:center;">删除属性值</td></tr><tr><td style="text-align:left;">[[GetPrototypeOf]]</td><td style="text-align:right;">() =&gt; Object|Null</td><td style="text-align:center;">获取提供继承属性的对象</td></tr></tbody></table><h2 id="内部方法的多态性" tabindex="-1">内部方法的多态性 <a class="header-anchor" href="#内部方法的多态性" aria-label="Permalink to &quot;内部方法的多态性&quot;">​</a></h2><p>js 的内部方法具有多态性，这有点类似于面向对象里多态的概念。不同类型的对象部署了相同的内部方法，却具有不同的逻辑。</p><p>例如，普通对象和 proxy 对象都部署了 <code>[[Get]]</code> 方法，但它们的逻辑是不同的。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> p</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> new</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> Proxy</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(obj, {</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">  /* ... */</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">});</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">p.foo;</span></span></code></pre></div><p>p 是一个代理对象，当执行 <code>p.foo</code> 引擎会调用部署在 p 上的内部方法 <code>[[Get]]</code> ，代理对象的 <code>[[Get]]</code> 和普通对象的逻辑不同，它会优先执行拦截函数 <code>get()</code> ，若没有设置拦截函数，代理对象的内部方法 <code>[[Get]]</code> 会调用原始对象的内部方法 <code>[[Get]]</code> 来获取属性值，这就是 <code>代理透明性质</code> 。</p><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>综上得知，js针对代理对象，重写了底层内部方法，使得在执行代理对象语义时，让拦截函数优先，不存在拦截函数才执行原始对象内部方法，利用 <code>代理透明性质</code> 实现了对象代理。</p>`,15),o=[l];function d(n,r,p,c,h,y){return a(),e("div",null,o)}const x=t(i,[["render",d]]);export{k as __pageData,x as default};
